<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Paper_Theorems_Beautify (Isabelle2014: August 2014)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Paper_Theorems_Beautify</h1>

<span class="command">theory</span> <span class="name">Paper_Theorems_Beautify</span><br/>
<span class="keyword">imports</span> <a href="../MSO_Derivatives/WS1S_Formula.html"><span class="name">WS1S_Formula</span></a><br/>

</div>
<div class="source">
<pre><span class="comment">(*&lt;*)</span>
<span class="command">theory</span> Paper_Theorems_Beautify
<span class="keyword2">imports</span> WS1S_Formula
<span class="keyword2">begin</span>

<span class="command">hide_const</span> <span class="delimiter">(</span><span class="keyword2">open</span><span class="delimiter">)</span> wf
<span class="command">hide_const</span> <span class="delimiter">(</span><span class="keyword2">open</span><span class="delimiter">)</span> Not
<span class="command">no_notation</span> Cons <span class="delimiter">(</span><span class="keyword2">infixr</span> <span class="string">&quot;#&quot;</span> 65<span class="delimiter">)</span>
<span class="command">no_notation</span> Full <span class="delimiter">(</span><span class="string">&quot;&Sigma;<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span><span class="delimiter">)</span>

<span class="command">type_synonym</span> <span class="tfree">&#39;a</span> lang <span class="delimiter">=</span> <span class="string">&quot;&#39;a language&quot;</span>
<span class="command">abbreviation</span> in_language_syn <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;&isin;&quot;</span> 66<span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;w &isin; L &equiv; in_language L w&quot;</span>
<span class="command">abbreviation</span> \&lt;dd&gt;_syn <span class="delimiter">(</span><span class="string">&quot;(_)<span class="hidden">&#8681;</span><sub>_</sub>&quot;</span><span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;(L)<span class="hidden">&#8681;</span><sub>a</sub> &equiv; \&lt;dd&gt; L a&quot;</span>
<span class="command">abbreviation</span> star <span class="delimiter">(</span><span class="string">&quot;_<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span><span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;&Sigma;<span class="hidden">&#8679;</span><sup>*</sup> &equiv; lists (set &Sigma;)&quot;</span>
<span class="command">type_synonym</span> letter <span class="delimiter">=</span> <span class="string">&quot;bool list &times; bool list&quot;</span>
<span class="command">type_synonym</span> interp_size <span class="delimiter">=</span> idx
<span class="command">abbreviation</span> <span class="string">&quot;bisim wf &Sigma; &iota; &delta; \&lt;o&gt; &equiv; DA.check_eqv &Sigma; &iota; &delta; \&lt;o&gt; (&lambda;s. wf (&iota; s))&quot;</span>
<span class="command">notation</span> check_eqv <span class="delimiter">(</span><span class="string">&quot;eqv&quot;</span><span class="delimiter">)</span>
<span class="command">notation</span> bounded_check_eqv <span class="delimiter">(</span><span class="string">&quot;eqv<span class="hidden">&#8681;</span><sub>&lt;</sub>&quot;</span><span class="delimiter">)</span>
<span class="command">notation</span> Length <span class="delimiter">(</span><span class="string">&quot;#_&quot;</span> <span class="delimiter">[</span>59<span class="delimiter">]</span> 60<span class="delimiter">)</span>
<span class="command">abbreviation</span> <span class="string">&quot;T &equiv; FBool True&quot;</span>
<span class="command">abbreviation</span> <span class="string">&quot;F &equiv; FBool False&quot;</span>
<span class="command">abbreviation</span> <span class="string">&quot;FOV &phi; &equiv; {i. (FO, i) &isin; set (FV &phi;)}&quot;</span>
<span class="command">abbreviation</span> FOassign1 <span class="delimiter">(</span><span class="string">&quot;_[_]<span class="hidden">&#8681;</span><sub>1</sub>&quot;</span> <span class="delimiter">[</span>59<span class="delimiter">,</span> 60<span class="delimiter">]</span> 60<span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;I[x]<span class="hidden">&#8681;</span><sub>1</sub> &equiv; fset (x<span class="hidden">&#8663;</span><sup>I<span class="hidden">&#8662;</span></sup>FO)&quot;</span>
<span class="command">abbreviation</span> FOassign2 <span class="delimiter">(</span><span class="string">&quot;_[_]<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span> <span class="delimiter">[</span>59<span class="delimiter">,</span> 60<span class="delimiter">]</span> 60<span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;I[x]<span class="hidden">&#8681;</span><sub>2</sub> &equiv; fset (x<span class="hidden">&#8663;</span><sup>I<span class="hidden">&#8662;</span></sup>SO)&quot;</span>
<span class="command">abbreviation</span> Extend1as2 <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;::<span class="hidden">&#8681;</span><sub>1</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>2</sub>&quot;</span> 67<span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;P ::<span class="hidden">&#8681;</span><sub>1</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>2</sub> I &equiv; Extend FO 0 I (Abs_fset P)&quot;</span>
<span class="command">abbreviation</span> Extend1 <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;::<span class="hidden">&#8681;</span><sub>1</sub>&quot;</span> 67<span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;p ::<span class="hidden">&#8681;</span><sub>1</sub> I &equiv; Extend FO 0 I {|p|}&quot;</span>
<span class="command">abbreviation</span> Extend2 <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;::<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span> 67<span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;P ::<span class="hidden">&#8681;</span><sub>2</sub> I &equiv; Extend SO 0 I (Abs_fset P)&quot;</span>
<span class="command">abbreviation</span> Lt <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;&lt;&quot;</span> 66<span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;i &lt; j &equiv; FBase (Less i j)&quot;</span>
<span class="command">abbreviation</span> Mem <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;&isin;&quot;</span> 66<span class="delimiter">)</span>  <span class="keyword2">where</span> <span class="string">&quot;i &isin; I &equiv; FBase (In i I)&quot;</span>
<span class="command">abbreviation</span> Not <span class="delimiter">(</span><span class="string">&quot;&not;_&quot;</span><span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;Not &equiv; FNot&quot;</span>
<span class="command">abbreviation</span> Or <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;&or;&quot;</span> 66<span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;Or &equiv; FOr&quot;</span>
<span class="command">abbreviation</span> Ex<span class="hidden">&#8681;</span><sub>1</sub> <span class="delimiter">(</span><span class="string">&quot;&exist;<span class="hidden">&#8681;</span><sub>1</sub>_&quot;</span><span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;Ex<span class="hidden">&#8681;</span><sub>1</sub> &equiv; FEx FO&quot;</span>
<span class="command">abbreviation</span> Ex<span class="hidden">&#8681;</span><sub>2</sub> <span class="delimiter">(</span><span class="string">&quot;&exist;<span class="hidden">&#8681;</span><sub>2</sub>_&quot;</span><span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;Ex<span class="hidden">&#8681;</span><sub>2</sub> &equiv; FEx SO&quot;</span>
<span class="command">abbreviation</span> Abs_idx_curry <span class="delimiter">(</span><span class="string">&quot;&lang;_, _&rang;&quot;</span> <span class="delimiter">[</span>59<span class="delimiter">,</span> 60<span class="delimiter">]</span> 1000<span class="delimiter">)</span> <span class="keyword2">where</span> <span class="string">&quot;Abs_idx_curry x y &equiv; Abs_idx (x, y)&quot;</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible fset_empty_iff<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;fset P = {} &lt;-&gt; P = {||}&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis bot_fset.rep_eq fset_inverse<span class="delimiter">)</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible satisfies0_singleton_fMin<span class="delimiter">:</span> <span class="string">&quot;[|P &ne; {||}; LEQ FO i (#<span class="hidden">&#8681;</span><sub>V</sub> I)|] ==&gt;
  satisfies0 (Extend FO i I P) a = satisfies0 (Extend FO i I {|fMin P|}) a&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct a<span class="delimiter">)</span> auto

<span class="command">lemma</span> <span class="delimiter">%</span>invisible satisfies_gen_singleton_fMin<span class="delimiter">:</span>
  <span class="keyword2">defines</span> <span class="string">&quot;sat &equiv; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True)&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;LEQ FO i (#<span class="hidden">&#8681;</span><sub>V</sub> I) ==&gt; sat (Extend FO i I P) &phi; =
    sat (Extend FO i I (if P = {||} then {||} else {|fMin P|})) &phi;&quot;</span>
  <span class="command">apply</span> <span class="delimiter">(</span>split if_splits<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>intro conjI impI<span class="delimiter">)</span>
  <span class="command">apply</span> simp
  <span class="command">apply</span> <span class="delimiter">(</span>rotate_tac -1<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>induct &phi; arbitrary<span class="delimiter">:</span> i I<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> satisfies0_singleton_fMin<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> sat_def Extend_commute_unsafe split<span class="delimiter">:</span> order.splits<span class="delimiter">)</span>
<span class="command">proof</span> -
  <span class="command">fix</span> x1a <span class="delimiter">::</span> order <span class="keyword2">and</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span>
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;!!i I. LEQ FO i (#<span class="hidden">&#8681;</span><sub>V</sub> I) ==&gt; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend FO i I P) &phi;&#39; = Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend FO i I {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;LEQ FO ia (#<span class="hidden">&#8681;</span><sub>V</sub> Ia)&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend x1a 0 (Extend FO ia Ia P) Pa) &phi;&#39;&quot;</span>
  <span class="command">have</span> f4<span class="delimiter">:</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub>. LEQ FO ia (SUC x<span class="hidden">&#8681;</span><sub>0</sub> (#<span class="hidden">&#8681;</span><sub>V</sub> Ia))&quot;</span> <span class="command">using</span> a2 LESS_SUC<span class="delimiter">(</span>4<span class="delimiter">)</span> SUC_SUC <span class="command">by</span> presburger
  <span class="command">have</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub> x<span class="hidden">&#8681;</span><sub>1</sub>. Extend FO 0 (Extend FO ia Ia x<span class="hidden">&#8681;</span><sub>0</sub>) x<span class="hidden">&#8681;</span><sub>1</sub> = Extend FO (Suc ia) (Extend FO 0 Ia x<span class="hidden">&#8681;</span><sub>1</sub>) x<span class="hidden">&#8681;</span><sub>0</sub>&quot;</span> <span class="command">using</span> a2 WS1S.Extend_commute_safe <span class="command">by</span> blast
  <span class="command">thus</span> <span class="string">&quot;&exist;Pa. Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend x1a 0 (Extend FO ia Ia {|fMin P|}) Pa) &phi;&#39;&quot;</span> <span class="command">using</span> a1 a2 a3 f4 <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">)</span> LESS_SUC<span class="delimiter">(</span>2<span class="delimiter">)</span> WS1S.Extend_commute_unsafe WS1S.nvars_Extend<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> x1a <span class="delimiter">::</span> order <span class="keyword2">and</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span>
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;!!i I. LEQ FO i (#<span class="hidden">&#8681;</span><sub>V</sub> I) ==&gt; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend FO i I P) &phi;&#39; = Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend FO i I {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;LEQ FO ia (#<span class="hidden">&#8681;</span><sub>V</sub> Ia)&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend x1a 0 (Extend FO ia Ia {|fMin P|}) Pa) &phi;&#39;&quot;</span>
  <span class="command">have</span> f4<span class="delimiter">:</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub>. LEQ FO ia (SUC x<span class="hidden">&#8681;</span><sub>0</sub> (#<span class="hidden">&#8681;</span><sub>V</sub> Ia))&quot;</span> <span class="command">using</span> a2 LESS_SUC<span class="delimiter">(</span>4<span class="delimiter">)</span> SUC_SUC <span class="command">by</span> presburger
  <span class="command">have</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub> x<span class="hidden">&#8681;</span><sub>1</sub>. Extend FO 0 (Extend FO ia Ia x<span class="hidden">&#8681;</span><sub>0</sub>) x<span class="hidden">&#8681;</span><sub>1</sub> = Extend FO (Suc ia) (Extend FO 0 Ia x<span class="hidden">&#8681;</span><sub>1</sub>) x<span class="hidden">&#8681;</span><sub>0</sub>&quot;</span> <span class="command">using</span> a2 WS1S.Extend_commute_safe <span class="command">by</span> blast
  <span class="command">thus</span> <span class="string">&quot;&exist;Pa. Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend x1a 0 (Extend FO ia Ia P) Pa) &phi;&#39;&quot;</span> <span class="command">using</span> a1 a2 a3 f4 <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">)</span> LESS_SUC<span class="delimiter">(</span>2<span class="delimiter">)</span> WS1S.Extend_commute_unsafe WS1S.nvars_Extend<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> x1a <span class="delimiter">::</span> order <span class="keyword2">and</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span>
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;!!i I. LEQ FO i (#<span class="hidden">&#8681;</span><sub>V</sub> I) ==&gt; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend FO i I P) &phi;&#39; = Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend FO i I {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;LEQ FO ia (#<span class="hidden">&#8681;</span><sub>V</sub> Ia)&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;&forall;Pa. Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend x1a 0 (Extend FO ia Ia P) Pa) &phi;&#39;&quot;</span>
  <span class="command">have</span> f4<span class="delimiter">:</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub>. LEQ FO ia (SUC x<span class="hidden">&#8681;</span><sub>0</sub> (#<span class="hidden">&#8681;</span><sub>V</sub> Ia))&quot;</span> <span class="command">using</span> a2 LESS_SUC<span class="delimiter">(</span>4<span class="delimiter">)</span> SUC_SUC <span class="command">by</span> presburger
  <span class="command">have</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub> x<span class="hidden">&#8681;</span><sub>1</sub>. Extend FO 0 (Extend FO ia Ia x<span class="hidden">&#8681;</span><sub>0</sub>) x<span class="hidden">&#8681;</span><sub>1</sub> = Extend FO (Suc ia) (Extend FO 0 Ia x<span class="hidden">&#8681;</span><sub>1</sub>) x<span class="hidden">&#8681;</span><sub>0</sub>&quot;</span> <span class="command">using</span> a2 WS1S.Extend_commute_safe <span class="command">by</span> blast
  <span class="command">thus</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend x1a 0 (Extend FO ia Ia {|fMin P|}) Pa) &phi;&#39;&quot;</span> <span class="command">using</span> a1 a2 a3 f4 <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">)</span> LESS_SUC<span class="delimiter">(</span>2<span class="delimiter">)</span> WS1S.Extend_commute_unsafe WS1S.nvars_Extend<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> x1a <span class="delimiter">::</span> order <span class="keyword2">and</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span>
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;!!i I. LEQ FO i (#<span class="hidden">&#8681;</span><sub>V</sub> I) ==&gt; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend FO i I P) &phi;&#39; = Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend FO i I {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;LEQ FO ia (#<span class="hidden">&#8681;</span><sub>V</sub> Ia)&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;&forall;Pa. Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend x1a 0 (Extend FO ia Ia {|fMin P|}) Pa) &phi;&#39;&quot;</span>
  <span class="command">have</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>2</sub> x<span class="hidden">&#8681;</span><sub>0</sub> x<span class="hidden">&#8681;</span><sub>1</sub>. Extend FO x<span class="hidden">&#8681;</span><sub>0</sub> (Extend FO ia Ia x<span class="hidden">&#8681;</span><sub>1</sub>) x<span class="hidden">&#8681;</span><sub>2</sub> = Extend FO (Suc ia) (Extend FO x<span class="hidden">&#8681;</span><sub>0</sub> Ia x<span class="hidden">&#8681;</span><sub>2</sub>) x<span class="hidden">&#8681;</span><sub>1</sub> &or; &not; x<span class="hidden">&#8681;</span><sub>0</sub> &le; ia&quot;</span> <span class="command">using</span> a2 Extend_commute_safe <span class="command">by</span> blast
  <span class="command">thus</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. True) (Extend x1a 0 (Extend FO ia Ia P) Pa) &phi;&#39;&quot;</span> <span class="command">using</span> a1 a2 a3 <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">)</span> LESS_SUC<span class="delimiter">(</span>2<span class="delimiter">)</span> LESS_SUC<span class="delimiter">(</span>4<span class="delimiter">)</span> WS1S.Extend_commute_unsafe WS1S.nvars_Extend le0<span class="delimiter">)</span>
<span class="command">qed</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible satisfies_gen_restrict_singleton_fMin<span class="delimiter">:</span>
  <span class="keyword2">defines</span> <span class="string">&quot;sat &equiv; Formula_Operations.satisfies_gen Extend Length satisfies0
    (&lambda;k P n. case k of FO =&gt; P &ne; {||} | SO =&gt; True)&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;[|P &ne; {||}; LEQ FO i (#<span class="hidden">&#8681;</span><sub>V</sub> I)|] ==&gt; sat (Extend FO i I P) &phi; = sat (Extend FO i I {|fMin P|}) &phi;&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct &phi; arbitrary<span class="delimiter">:</span> i I<span class="delimiter">)</span>
    <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> satisfies0_singleton_fMin<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> sat_def WS1S.LEQ_SUC Extend_commute_unsafe split<span class="delimiter">:</span> order.splits<span class="delimiter">)</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible satisfies_gen_restrict_bounded_singleton_fMin<span class="delimiter">:</span>
  <span class="keyword2">defines</span> <span class="string">&quot;sat &equiv; Formula_Operations.satisfies_gen Extend Length satisfies0
    (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n)&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;[|P &ne; {||}; len P &le; Length I; LEQ FO i (#<span class="hidden">&#8681;</span><sub>V</sub> I)|] ==&gt; sat (Extend FO i I P) &phi; = sat (Extend FO i I {|fMin P|}) &phi;&quot;</span>
  <span class="command">apply</span> <span class="delimiter">(</span>induct &phi; arbitrary<span class="delimiter">:</span> i I<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto 0 0 simp add<span class="delimiter">:</span> satisfies0_singleton_fMin<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> sat_def WS1S.LEQ_SUC Extend_commute_unsafe split<span class="delimiter">:</span> order.splits<span class="delimiter">)</span>
<span class="comment">(*
  apply (smt2 equalsffemptyD fMax_ge fMin_le le_less_trans len_def less_Suc_eq_le max_def not_le)+
*)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">,</span> lifting<span class="delimiter">)</span> equalsffemptyD le_max_iff_disj len_def max.orderE<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">,</span> lifting<span class="delimiter">)</span> equalsffemptyD le_max_iff_disj len_def max.orderE<span class="delimiter">)</span>
  <span class="command">defer</span>
  <span class="command">apply</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">,</span> lifting<span class="delimiter">)</span> Suc_leI equalsffemptyD fMax_ge fMin_le leD le_less_trans len_def max_absorb1 not_less_eq<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">,</span> lifting<span class="delimiter">)</span> fMax_ge fMin_le finsert_absorb finsert_not_fempty len_def max.bounded_iff max.order_iff not_less_eq_eq<span class="delimiter">)</span>

<span class="command">proof</span> -
  <span class="command">fix</span> x1a <span class="delimiter">::</span> order <span class="keyword2">and</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span> <span class="keyword2">and</span> xa <span class="delimiter">::</span> nat
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;len P &le; #Ia&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;x |&isin;| P&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO (Suc ia) (Extend FO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a4<span class="delimiter">:</span> <span class="string">&quot;&forall;Pa. x1a = FO &and; (len Pa &le; max (#Ia) (Suc (fMax P)) --&gt; Pa = {||} &or; &not; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO (Suc ia) (Extend FO 0 Ia Pa) {|fMin P|}) &phi;&#39;) &or; x1a = SO &and; (len Pa &le; max (#Ia) (Suc (fMax P)) --&gt; &not; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO ia (Extend SO 0 Ia Pa) {|fMin P|}) &phi;&#39;)&quot;</span>
  <span class="command">assume</span> a5<span class="delimiter">:</span> <span class="string">&quot;xa |&isin;| Pa&quot;</span>
  <span class="command">assume</span> a6<span class="delimiter">:</span> <span class="string">&quot;len Pa &le; max (#Ia) (Suc (fMin P))&quot;</span>
  <span class="command">assume</span> a7<span class="delimiter">:</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO ia (Extend SO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">have</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>1</sub>. len Pa &le; max (#Ia) x<span class="hidden">&#8681;</span><sub>1</sub>&quot;</span> <span class="command">using</span> a1 a2 a6 <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">)</span> WS1S.len_add fMin_le finsert_absorb le_max_iff_disj max.order_iff not_less_eq_eq<span class="delimiter">)</span>
  <span class="command">thus</span> False <span class="command">using</span> a3 a4 a5 a7 <span class="command">by</span> blast
<span class="command">next</span>
  <span class="command">fix</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span> <span class="keyword2">and</span> xa <span class="delimiter">::</span> nat
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;len P &le; #Ia&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;x |&isin;| P&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;&forall;Pa. Pa &ne; {||} &and; len Pa &le; max (#Ia) (Suc (fMax P)) --&gt; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO (Suc ia) (Extend FO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a4<span class="delimiter">:</span> <span class="string">&quot;len Pa &le; max (#Ia) (Suc (fMin P))&quot;</span>
  <span class="command">assume</span> a5<span class="delimiter">:</span> <span class="string">&quot;&not; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO (Suc ia) (Extend FO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a6<span class="delimiter">:</span> <span class="string">&quot;xa |&isin;| Pa&quot;</span>
  <span class="command">have</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>1</sub>. len Pa &le; max (#Ia) x<span class="hidden">&#8681;</span><sub>1</sub>&quot;</span> <span class="command">using</span> a1 a2 a4 <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">)</span> WS1S.len_add fMin_le finsert_absorb le_max_iff_disj max.order_iff not_less_eq_eq<span class="delimiter">)</span>
  <span class="command">thus</span> False <span class="command">using</span> a3 a5 a6 <span class="command">by</span> blast
<span class="command">next</span>
  <span class="command">fix</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span>
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;len P &le; #Ia&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;x |&isin;| P&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;&forall;Pa. len Pa &le; max (#Ia) (Suc (fMax P)) --&gt; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO ia (Extend SO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> <span class="string">&quot;len Pa &le; max (#Ia) (Suc (fMin P))&quot;</span>
  <span class="command">hence</span> f4<span class="delimiter">:</span> <span class="string">&quot;len Pa &le; max (Suc (fMin P)) (#Ia)&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> max.commute<span class="delimiter">)</span>
  <span class="command">have</span> f5<span class="delimiter">:</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub>. &not; len x<span class="hidden">&#8681;</span><sub>0</sub> &le; max (Suc (fMax P)) (#Ia) &or; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;uu uua uub. (case uu of FO =&gt; uua &ne; {||} | SO =&gt; True) &and; len uua &le; uub) (Extend FO ia (Extend SO 0 Ia x<span class="hidden">&#8681;</span><sub>0</sub>) {|fMin P|}) &phi;&#39;&quot;</span> <span class="command">using</span> a3 <span class="command">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> max.commute<span class="delimiter">)</span>
  <span class="command">have</span> <span class="string">&quot;max (Suc (fMin P)) (#Ia) = #Ia&quot;</span> <span class="command">using</span> a1 a2 <span class="command">by</span> <span class="delimiter">(</span>metis WS1S.len_add fMin_le finsert_absorb max.absorb_iff2 max.coboundedI2 max.commute not_less_eq_eq<span class="delimiter">)</span>
  <span class="command">thus</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO ia (Extend SO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span> <span class="command">using</span> f4 f5 <span class="command">by</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> max.coboundedI2<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span> <span class="keyword2">and</span> xa <span class="delimiter">::</span> nat
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;len P &le; #Ia&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;x |&isin;| P&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;&forall;Pa. Pa &ne; {||} &and; len Pa &le; max (#Ia) (Suc (fMin P)) --&gt; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO (Suc ia) (Extend FO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a4<span class="delimiter">:</span> <span class="string">&quot;len Pa &le; max (#Ia) (Suc (fMax P))&quot;</span>
  <span class="command">assume</span> a5<span class="delimiter">:</span> <span class="string">&quot;&not; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO (Suc ia) (Extend FO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a6<span class="delimiter">:</span> <span class="string">&quot;xa |&isin;| Pa&quot;</span>
  <span class="command">have</span> f7<span class="delimiter">:</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub>. &not; len x<span class="hidden">&#8681;</span><sub>0</sub> &le; max (Suc (fMin P)) (#Ia) &or; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;uu uua uub. (case uu of FO =&gt; uua &ne; {||} | SO =&gt; True) &and; len uua &le; uub) (Extend FO (Suc ia) (Extend FO 0 Ia x<span class="hidden">&#8681;</span><sub>0</sub>) {|fMin P|}) &phi;&#39; &or; {||} = x<span class="hidden">&#8681;</span><sub>0</sub>&quot;</span> <span class="command">using</span> a3 <span class="command">unfolding</span> max.commute <span class="command">by</span> blast
  <span class="command">have</span> <span class="string">&quot;&forall;x<span class="hidden">&#8681;</span><sub>0</sub>. len Pa &le; max x<span class="hidden">&#8681;</span><sub>0</sub> (#Ia)&quot;</span> <span class="command">using</span> a1 a2 a4 <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">)</span> finsert_absorb finsert_not_fempty len_def max.absorb2 max.coboundedI1 max.commute<span class="delimiter">)</span>
  <span class="command">thus</span> False <span class="command">using</span> a5 a6 f7 <span class="command">by</span> blast
<span class="command">next</span>
  <span class="command">fix</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span>
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;x |&isin;| P&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;len P &le; #Ia&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;len Pa &le; max (#Ia) (Suc (fMax P))&quot;</span>
  <span class="command">assume</span> a4<span class="delimiter">:</span> <span class="string">&quot;&forall;Pa. len Pa &le; max (#Ia) (Suc (fMin P)) --&gt; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO ia (Extend SO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">have</span> <span class="string">&quot;len Pa &le; max (#Ia) (Suc (fMin P))&quot;</span> <span class="command">using</span> a1 a2 a3 <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>no_types<span class="delimiter">)</span> all_not_fin_conv dual_order.trans len_def max.cobounded2 max.commute max.order_iff<span class="delimiter">)</span>
  <span class="command">thus</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO ia (Extend SO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span> <span class="command">using</span> a4 <span class="command">by</span> blast
<span class="command">next</span>
  <span class="command">fix</span> x1a <span class="delimiter">::</span> order <span class="keyword2">and</span> &phi;&#39; <span class="delimiter">::</span> <span class="string">&quot;(ws1s, order) aformula&quot;</span> <span class="keyword2">and</span> ia <span class="delimiter">::</span> nat <span class="keyword2">and</span> Ia <span class="delimiter">::</span> interp <span class="keyword2">and</span> x <span class="delimiter">::</span> nat <span class="keyword2">and</span> Pa <span class="delimiter">::</span> <span class="string">&quot;nat fset&quot;</span> <span class="keyword2">and</span> xa <span class="delimiter">::</span> nat
  <span class="command">assume</span> a1<span class="delimiter">:</span> <span class="string">&quot;len P &le; #Ia&quot;</span>
  <span class="command">assume</span> a2<span class="delimiter">:</span> <span class="string">&quot;x |&isin;| P&quot;</span>
  <span class="command">assume</span> a3<span class="delimiter">:</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO (Suc ia) (Extend FO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">assume</span> a4<span class="delimiter">:</span> <span class="string">&quot;&forall;Pa. x1a = FO &and; (len Pa &le; max (#Ia) (Suc (fMin P)) --&gt; Pa = {||} &or; &not; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO (Suc ia) (Extend FO 0 Ia Pa) {|fMin P|}) &phi;&#39;) &or; x1a = SO &and; (len Pa &le; max (#Ia) (Suc (fMin P)) --&gt; &not; Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO ia (Extend SO 0 Ia Pa) {|fMin P|}) &phi;&#39;)&quot;</span>
  <span class="command">assume</span> a5<span class="delimiter">:</span> <span class="string">&quot;xa |&isin;| Pa&quot;</span>
  <span class="command">assume</span> a6<span class="delimiter">:</span> <span class="string">&quot;len Pa &le; max (#Ia) (Suc (fMax P))&quot;</span>
  <span class="command">assume</span> a7<span class="delimiter">:</span> <span class="string">&quot;Formula_Operations.satisfies_gen Extend Length satisfies0 (&lambda;k P n. (case k of FO =&gt; P &ne; {||} | SO =&gt; True) &and; len P &le; n) (Extend FO ia (Extend SO 0 Ia Pa) {|fMin P|}) &phi;&#39;&quot;</span>
  <span class="command">have</span> f8<span class="delimiter">:</span> <span class="string">&quot;{||} &ne; Pa&quot;</span> <span class="command">using</span> a5 <span class="command">by</span> force
  <span class="command">have</span> <span class="string">&quot;len Pa &le; #Ia&quot;</span> <span class="command">using</span> a1 a2 a6 <span class="command">by</span> <span class="delimiter">(</span>metis finsert_absorb finsert_not_fempty len_def max.absorb_iff2 max.commute<span class="delimiter">)</span>
  <span class="command">thus</span> False <span class="command">using</span> a3 a4 a7 f8 max.cobounded1 order_trans <span class="command">by</span> blast
<span class="command">qed</span>

<span class="command">abbreviation</span> FO <span class="keyword2">where</span> <span class="string">&quot;FO i &equiv; FBase (Q i)&quot;</span>
<span class="command">notation</span> WS1S.sat <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;\&lt;turnstile&gt;&quot;</span> 66<span class="delimiter">)</span>
<span class="command">notation</span> WS1S.sat<span class="hidden">&#8681;</span><sub>b</sub> <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;\&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub>&quot;</span> 66<span class="delimiter">)</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible ws1s_left_formula_triv<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;ws1s_left_formula &phi; = True&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct &phi;<span class="delimiter">)</span> auto

<span class="command">lemma</span> <span class="delimiter">%</span>invisible len_leq_iff<span class="delimiter">:</span> <span class="string">&quot;len P &le; n &lt;-&gt; (&forall;p &isin; fset P. p &lt; n)&quot;</span>
  <span class="command">unfolding</span> len_def
  <span class="command">by</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Suc_le_eq fmember.rep_eq<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> Ball_def intro<span class="delimiter">:</span> fMax_boundedD<span class="delimiter">(</span>1<span class="delimiter">)</span> fMax_in<span class="delimiter">)</span>

<span class="command">primrec</span> satisfies <span class="delimiter">::</span> <span class="string">&quot;interp =&gt; formula =&gt; bool&quot;</span> <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;\&lt;Turnstile&gt;&quot;</span> 50<span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;I \&lt;Turnstile&gt; (FBool b) = b&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt; (FBase a) = satisfies0 I a&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt; (FNot &phi;) = (&not; I \&lt;Turnstile&gt; &phi;)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt; (FOr &phi;<span class="hidden">&#8681;</span><sub>1</sub> &phi;<span class="hidden">&#8681;</span><sub>2</sub>) = (I \&lt;Turnstile&gt; &phi;<span class="hidden">&#8681;</span><sub>1</sub> &or; I \&lt;Turnstile&gt; &phi;<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt; (FAnd &phi;<span class="hidden">&#8681;</span><sub>1</sub> &phi;<span class="hidden">&#8681;</span><sub>2</sub>) = (I \&lt;Turnstile&gt; &phi;<span class="hidden">&#8681;</span><sub>1</sub> &and; I \&lt;Turnstile&gt; &phi;<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt; (FEx k &phi;) = (case k of WS1S_Formula.FO =&gt; &exist;p. p::<span class="hidden">&#8681;</span><sub>1</sub>I \&lt;Turnstile&gt; &phi; | SO =&gt; &exist;P. finite P &and; P::<span class="hidden">&#8681;</span><sub>2</sub>I \&lt;Turnstile&gt; &phi;)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt; (FAll k &phi;) = (case k of WS1S_Formula.FO =&gt; &forall;p. p::<span class="hidden">&#8681;</span><sub>1</sub>I \&lt;Turnstile&gt; &phi; | SO =&gt; &forall;P. finite P --&gt; P::<span class="hidden">&#8681;</span><sub>2</sub>I \&lt;Turnstile&gt; &phi;)&quot;</span>

<span class="command">primrec</span> satisfies_bounded <span class="delimiter">::</span> <span class="string">&quot;interp =&gt; formula =&gt; bool&quot;</span> <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;\&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub>&quot;</span> 50<span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FBool b) = b&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FBase a) = satisfies0 I a&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FNot &phi;) = (&not; I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FOr &phi;<span class="hidden">&#8681;</span><sub>1</sub> &phi;<span class="hidden">&#8681;</span><sub>2</sub>) = (I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;<span class="hidden">&#8681;</span><sub>1</sub> &or; I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FAnd &phi;<span class="hidden">&#8681;</span><sub>1</sub> &phi;<span class="hidden">&#8681;</span><sub>2</sub>) = (I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;<span class="hidden">&#8681;</span><sub>1</sub> &and; I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FEx k &phi;) = (case k of WS1S_Formula.FO =&gt; &exist;p&lt;#I. p::<span class="hidden">&#8681;</span><sub>1</sub>I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi; | SO =&gt; &exist;P. (&forall;p &isin; P. p &lt; #I) &and; P::<span class="hidden">&#8681;</span><sub>2</sub>I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FAll k &phi;) = (case k of WS1S_Formula.FO =&gt; &forall;p&lt;#I. p::<span class="hidden">&#8681;</span><sub>1</sub>I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi; | SO =&gt; &forall;P. (&forall;p &isin; P. p &lt; #I) --&gt; P::<span class="hidden">&#8681;</span><sub>2</sub>I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;)&quot;</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible sat_def<span class="delimiter">:</span>
  <span class="keyword2">fixes</span> I <span class="delimiter">::</span> interp
  <span class="keyword2">and</span> x y X <span class="delimiter">::</span> nat
  <span class="keyword2">and</span> &phi; &psi; <span class="delimiter">::</span> formula
  <span class="keyword2">shows</span>
  <span class="string">&quot;I \&lt;turnstile&gt; T &lt;-&gt; True&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; F &lt;-&gt; False&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (FO x) &lt;-&gt; I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {}&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (x &lt; y) &lt;-&gt;
     Min (I[x]<span class="hidden">&#8681;</span><sub>1</sub>) &lt; Min (I[y]<span class="hidden">&#8681;</span><sub>1</sub>) &and; I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {} &and; I[y]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {}&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (x &isin; X) &lt;-&gt;
     Min (I[x]<span class="hidden">&#8681;</span><sub>1</sub>) &isin; I[X]<span class="hidden">&#8681;</span><sub>2</sub> &and; I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {} &and; finite (I[X]<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (&not; &phi;) &lt;-&gt; &not; (I \&lt;turnstile&gt; &phi;) &and; (&forall;x &isin; FOV (&not; &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (&phi; &or; &psi;) &lt;-&gt;
     (I \&lt;turnstile&gt; &phi; &or; I \&lt;turnstile&gt; &psi;) &and; (&forall;x &isin; FOV (&phi; &or; &psi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (FAnd &phi; &psi;) &lt;-&gt;
     (I \&lt;turnstile&gt; &phi; &and; I \&lt;turnstile&gt; &psi;) &and; (&forall;x &isin; FOV (FAnd &phi; &psi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (&exist;<span class="hidden">&#8681;</span><sub>1</sub> &phi;) &lt;-&gt;
     (&exist;p. p::<span class="hidden">&#8681;</span><sub>1</sub>I \&lt;turnstile&gt; &phi;) &and; (&forall;x &isin; FOV (&exist;<span class="hidden">&#8681;</span><sub>1</sub> &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (&exist;<span class="hidden">&#8681;</span><sub>2</sub> &phi;) &lt;-&gt;
     (&exist;P. finite P &and; P::<span class="hidden">&#8681;</span><sub>2</sub>I \&lt;turnstile&gt; &phi;) &and; (&forall;x &isin; FOV (&exist;<span class="hidden">&#8681;</span><sub>2</sub> &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (FAll WS1S_Formula.FO &phi;) &lt;-&gt;
     (&forall;p. p::<span class="hidden">&#8681;</span><sub>1</sub>I \&lt;turnstile&gt; &phi;) &and; (&forall;x &isin; FOV (FAll WS1S_Formula.FO &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt; (FAll SO &phi;) &lt;-&gt;
     (&forall;P. finite P --&gt; P::<span class="hidden">&#8681;</span><sub>2</sub>I \&lt;turnstile&gt; &phi;) &and; (&forall;x &isin; FOV (FAll SO &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Formula_Operations.sat_def Formula_Operations.FV.simps
     FV_def restrict_def dec_def Let_def fMin.rep_eq fmember.rep_eq split<span class="delimiter">:</span> order.splits prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span>8<span class="delimiter">]</span>
     <span class="command">apply</span> <span class="delimiter">(</span>simp_all add<span class="delimiter">:</span> Formula_Operations.sat_def Formula_Operations.FV.simps
       FV_def restrict_def dec_def Let_def fMin.rep_eq fmember.rep_eq split<span class="delimiter">:</span> order.splits prod.splits<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>auto 0 2<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="command">apply</span> <span class="delimiter">(</span>metis LESS_SUC<span class="delimiter">(</span>1<span class="delimiter">)</span> all_not_fin_conv satisfies_gen_restrict_singleton_fMin<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 less_irrefl_nat prod.inject<span class="delimiter">)</span>  
    <span class="command">apply</span> <span class="delimiter">(</span>auto 1 0<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
     <span class="command">apply</span> <span class="delimiter">(</span>rule_tac x <span class="delimiter">=</span> <span class="string">&quot;fset P&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> fset_inverse<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 order.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
    <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 order.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto 0 2<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 less_irrefl_nat prod.inject<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>asm<span class="delimiter">)</span> <span class="delimiter">(</span>2<span class="delimiter">)</span> satisfies_gen_restrict_singleton_fMin<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> gr0_conv_Suc<span class="delimiter">)</span> <span class="delimiter">[</span>3<span class="delimiter">]</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto 0 0<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
     <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 order.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
    <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 order.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> <span class="string">&quot;fset P&quot;</span> <span class="keyword2">in</span> spec<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> fset_inverse<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>metis finite_fset<span class="delimiter">)</span>
  <span class="command">done</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible sat<span class="hidden">&#8681;</span><sub>b</sub>_def<span class="delimiter">:</span>
  <span class="keyword2">fixes</span> I <span class="delimiter">::</span> interp
  <span class="keyword2">and</span> x y X <span class="delimiter">::</span> nat
  <span class="keyword2">and</span> &phi; &psi; <span class="delimiter">::</span> formula
  <span class="keyword2">shows</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> T &lt;-&gt; True&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> F &lt;-&gt; False&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FO x) &lt;-&gt; I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {}&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (x &lt; y) &lt;-&gt;
     Min (I[x]<span class="hidden">&#8681;</span><sub>1</sub>) &lt; Min (I[y]<span class="hidden">&#8681;</span><sub>1</sub>) &and; I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {} &and; I[y]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {}&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (x &isin; X) &lt;-&gt;
     Min (I[x]<span class="hidden">&#8681;</span><sub>1</sub>) &isin; I[X]<span class="hidden">&#8681;</span><sub>2</sub> &and; I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {} &and; finite (I[X]<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (&not; &phi;) &lt;-&gt; &not; (I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;) &and; (&forall;x &isin; FOV (&not; &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (&phi; &or; &psi;) &lt;-&gt;
     (I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi; &or; I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &psi;) &and; (&forall;x &isin; FOV (&phi; &or; &psi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FAnd &phi; &psi;) &lt;-&gt;
     (I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi; &and; I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &psi;) &and; (&forall;x &isin; FOV (FAnd &phi; &psi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (&exist;<span class="hidden">&#8681;</span><sub>1</sub> &phi;) &lt;-&gt;
     (&exist;p. p &lt; #I &and; p::<span class="hidden">&#8681;</span><sub>1</sub>I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;) &and; (&forall;x &isin; FOV (&exist;<span class="hidden">&#8681;</span><sub>1</sub> &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (&exist;<span class="hidden">&#8681;</span><sub>2</sub> &phi;) &lt;-&gt;
     (&exist;P. (&forall;p &isin; P. p &lt; #I) &and; P::<span class="hidden">&#8681;</span><sub>2</sub>I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;) &and;
     (&forall;x &isin; FOV (&exist;<span class="hidden">&#8681;</span><sub>2</sub> &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FAll WS1S_Formula.FO &phi;) &lt;-&gt;
     (&forall;p. p &lt; #I --&gt; p::<span class="hidden">&#8681;</span><sub>1</sub>I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;) &and; (&forall;x &isin; FOV (FAll WS1S_Formula.FO &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> (FAll SO &phi;) &lt;-&gt;
     (&forall;P. (&forall;p &isin; P. p &lt; #I) --&gt; P::<span class="hidden">&#8681;</span><sub>2</sub>I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi;) &and; (&forall;x &isin; FOV (FAll SO &phi;). I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {})&quot;</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> Formula_Operations.sat<span class="hidden">&#8681;</span><sub>b</sub>_def Formula_Operations.FV.simps
     FV_def restrict_def dec_def Let_def fMin.rep_eq fmember.rep_eq split<span class="delimiter">:</span> order.splits prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span>8<span class="delimiter">]</span>
     <span class="command">apply</span> <span class="delimiter">(</span>simp_all add<span class="delimiter">:</span> Formula_Operations.sat<span class="hidden">&#8681;</span><sub>b</sub>_def Formula_Operations.FV.simps
       FV_def restrict_def dec_def Let_def fMin.rep_eq fmember.rep_eq split<span class="delimiter">:</span> order.splits prod.splits<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>auto 0 2<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="command">apply</span> <span class="delimiter">(</span>rule_tac x <span class="delimiter">=</span> <span class="string">&quot;fMin P&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
      <span class="command">apply</span> <span class="delimiter">(</span>rule conjI<span class="delimiter">)</span>
       <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> len_def not_less split<span class="delimiter">:</span> if_splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
       <span class="command">apply</span> <span class="delimiter">(</span>metis fMax_ge fMin_le not_less_eq_eq order.trans<span class="delimiter">)</span>
      <span class="command">apply</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>asm<span class="delimiter">)</span> satisfies_gen_restrict_bounded_singleton_fMin<span class="delimiter">)</span>
         <span class="command">apply</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> fmember.rep_eq<span class="delimiter">)</span> <span class="delimiter">[</span>4<span class="delimiter">]</span>
      <span class="command">apply</span> <span class="delimiter">(</span>metis Pair_inject gr0_implies_Suc in_set_remove1 nat.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>rule_tac x <span class="delimiter">=</span> <span class="string">&quot;{|p|}&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> len_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>auto 1 0<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="command">apply</span> <span class="delimiter">(</span>rule_tac x <span class="delimiter">=</span> <span class="string">&quot;fset P&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
      <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> len_leq_iff fset_inverse<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="command">apply</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>hide_lams<span class="delimiter">)</span> in_set_remove1 order.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>hide_lams<span class="delimiter">)</span> in_set_remove1 order.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
    <span class="command">apply</span> <span class="delimiter">(</span>rule_tac x <span class="delimiter">=</span> <span class="string">&quot;Abs_fset P&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
    <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> len_leq_iff bounded_nat_set_is_finite Abs_fset_inverse<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto 0 2<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
     <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> <span class="string">&quot;{|p|}&quot;</span> <span class="keyword2">in</span> spec<span class="delimiter">)</span>
     <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> len_def<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 less_irrefl_nat prod.inject<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>asm<span class="delimiter">)</span> <span class="delimiter">(</span>2<span class="delimiter">)</span> satisfies_gen_restrict_bounded_singleton_fMin<span class="delimiter">)</span>
      <span class="command">apply</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> fmember.rep_eq<span class="delimiter">)</span> <span class="delimiter">[</span>4<span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> <span class="string">&quot;fMin P&quot;</span> <span class="keyword2">in</span> spec<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> len_def not_less split<span class="delimiter">:</span> if_splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>metis fMax_ge fMin_le not_less_eq_eq order.trans<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto 0 0<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
      <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> <span class="string">&quot;Abs_fset P&quot;</span> <span class="keyword2">in</span> spec<span class="delimiter">)</span>
      <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> len_leq_iff bounded_nat_set_is_finite Abs_fset_inverse<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
     <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 order.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
    <span class="command">apply</span> <span class="delimiter">(</span>metis in_set_remove1 order.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> <span class="string">&quot;fset P&quot;</span> <span class="keyword2">in</span> spec<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> len_leq_iff fset_inverse<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="command">apply</span> blast
  <span class="command">done</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible sat_alt<span class="delimiter">:</span>
  <span class="string">&quot;I \&lt;turnstile&gt; &phi; &lt;-&gt; (I \&lt;Turnstile&gt; &phi; &and; (&forall;x &isin; FOV &phi;. I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {}))&quot;</span>
  <span class="command">apply</span> <span class="delimiter">(</span>induct &phi; arbitrary<span class="delimiter">:</span> I<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> Formula_Operations.sat_def Formula_Operations.FV.simps
     FV_def restrict_def dec_def Let_def fMin.rep_eq fmember.rep_eq split<span class="delimiter">:</span> order.splits prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span>2<span class="delimiter">]</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> sat_def<span class="delimiter">)</span> <span class="delimiter">[</span>3<span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto 1 0 simp add<span class="delimiter">:</span> sat_def split<span class="delimiter">:</span> order.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dec_def gr0_conv_Suc<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> m <span class="keyword2">in</span> spec<span class="delimiter">)</span>
    <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> image_iff split<span class="delimiter">:</span> prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>metis diff_Suc_Suc diff_zero in_set_remove1 nat.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>rule_tac x <span class="delimiter">=</span> P <span class="keyword2">in</span> exI<span class="delimiter">)</span>
   <span class="command">apply</span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> x <span class="keyword2">in</span> spec<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto 0 2 simp<span class="delimiter">:</span> image_iff split<span class="delimiter">:</span> prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto 1 0 simp add<span class="delimiter">:</span> sat_def split<span class="delimiter">:</span> order.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dec_def gr0_conv_Suc<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> m <span class="keyword2">in</span> spec<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> image_iff split<span class="delimiter">:</span> prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>metis diff_Suc_Suc diff_zero in_set_remove1 nat.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> x <span class="keyword2">in</span> spec<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto 0 3 simp<span class="delimiter">:</span> image_iff split<span class="delimiter">:</span> prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="command">done</span>

<span class="command">lemma</span> <span class="delimiter">%</span>invisible sat<span class="hidden">&#8681;</span><sub>b</sub>_alt<span class="delimiter">:</span>
  <span class="string">&quot;I \&lt;turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi; &lt;-&gt; (I \&lt;Turnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub> &phi; &and; (&forall;x &isin; FOV &phi;. I[x]<span class="hidden">&#8681;</span><sub>1</sub> &ne; {}))&quot;</span>
  <span class="command">apply</span> <span class="delimiter">(</span>induct &phi; arbitrary<span class="delimiter">:</span> I<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> Formula_Operations.sat<span class="hidden">&#8681;</span><sub>b</sub>_def Formula_Operations.FV.simps
     FV_def restrict_def dec_def Let_def fMin.rep_eq fmember.rep_eq split<span class="delimiter">:</span> order.splits prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span>2<span class="delimiter">]</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> sat<span class="hidden">&#8681;</span><sub>b</sub>_def<span class="delimiter">)</span> <span class="delimiter">[</span>3<span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto 1 0 simp add<span class="delimiter">:</span> sat<span class="hidden">&#8681;</span><sub>b</sub>_def split<span class="delimiter">:</span> order.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>rule_tac x <span class="delimiter">=</span> p <span class="keyword2">in</span> exI<span class="delimiter">)</span>
    <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dec_def gr0_conv_Suc<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> m <span class="keyword2">in</span> spec<span class="delimiter">)</span>
    <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> image_iff split<span class="delimiter">:</span> prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
    <span class="command">apply</span> <span class="delimiter">(</span>metis diff_Suc_Suc diff_zero in_set_remove1 nat.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>rule_tac x <span class="delimiter">=</span> P <span class="keyword2">in</span> exI<span class="delimiter">)</span>
   <span class="command">apply</span> auto <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> x <span class="keyword2">in</span> spec<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto 0 2 simp<span class="delimiter">:</span> image_iff split<span class="delimiter">:</span> prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto 1 0 simp add<span class="delimiter">:</span> sat<span class="hidden">&#8681;</span><sub>b</sub>_def split<span class="delimiter">:</span> order.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> dec_def gr0_conv_Suc<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>rotate_tac 2<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> m <span class="keyword2">in</span> spec<span class="delimiter">)</span>
   <span class="command">apply</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> image_iff split<span class="delimiter">:</span> prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
   <span class="command">apply</span> <span class="delimiter">(</span>metis diff_Suc_Suc diff_zero in_set_remove1 nat.distinct<span class="delimiter">(</span>1<span class="delimiter">)</span> prod.inject<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>drule_tac x <span class="delimiter">=</span> x <span class="keyword2">in</span> spec<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>auto 0 3 simp<span class="delimiter">:</span> image_iff split<span class="delimiter">:</span> prod.splits<span class="delimiter">)</span> <span class="delimiter">[</span><span class="delimiter">]</span>
  <span class="command">done</span>

<span class="command">notation</span> WS1S.satisfies <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;\&lt;TTurnstile&gt;&quot;</span> 65<span class="delimiter">)</span>
<span class="command">notation</span> WS1S.satisfies_bounded <span class="delimiter">(</span><span class="keyword2">infix</span> <span class="string">&quot;\&lt;TTurnstile&gt;<span class="hidden">&#8681;</span><sub>&lt;</sub>&quot;</span> 65<span class="delimiter">)</span>
<span class="comment">(*&gt;*)</span>

<span class="command">end</span>
</pre>

</div>
</body>
</html>
