<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Coinductive_Language (Isabelle2014: August 2014)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Coinductive_Language</h1>

<span class="command">theory</span> <span class="name">Coinductive_Language</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>

</div>
<div class="source">
<pre><span class="comment">(*&lt;*)</span>
<span class="comment">(* Author: Dmitriy Traytel *)</span>

<span class="command">header</span> <span class="verbatim">{* A Codatatype of Formal Languages *}</span>

<span class="command">theory</span> Coinductive_Language
<span class="keyword2">imports</span> Main
<span class="keyword2">begin</span>

<span class="command">hide_const</span> <span class="delimiter">(</span><span class="keyword2">open</span><span class="delimiter">)</span> Inter
<span class="comment">(*&gt;*)</span>

<span class="command">section</span> <span class="verbatim">{* Introduction *}</span>

<span class="command">text</span> <span class="verbatim">{*
We define formal languages as a codataype of infinite trees branching over the
alphabet @{typ &#39;a}. Each node in such a tree indicates whether the path to this
node constitutes a word inside or outside of the language.

*}</span>

<span class="command">codatatype</span> <span class="tfree">&#39;a</span> language <span class="delimiter">=</span> Lang <span class="delimiter">(</span>\&lt;oo&gt;<span class="delimiter">:</span> bool<span class="delimiter">)</span> <span class="delimiter">(</span>\&lt;dd&gt;<span class="delimiter">:</span> <span class="string">&quot;&#39;a =&gt; &#39;a language&quot;</span><span class="delimiter">)</span>

<span class="command">text</span> <span class="verbatim">{* 
This codatatype is isormorphic to the set of lists representation of languages,
but caters for definitions by corecursion and proofs by coinduction.

Regular operations on languages are then defined by primitive corecursion.
A difficulty arises here, since the standard definitions of concatenation and
iteration from the coalgebraic literature are not primitively corecursive---they
require guardedness up-to union/concatenation. Without support for up-to corecursion,
these operation must be defined as a composition of primitive ones (and proved being
equal to the standard definitions). As an exercise in coinduction we also prove the
axioms of Kleene algebra for the defined regular operations.

Furthermore, a language for context-free grammars given by productions in Greibach
normal form and an initial nonterminal is constructed by primitive corecursion,
yielding an executable decision procedure for the word problem without further ado.
*}</span>
<span class="comment">(*&lt;*)</span>
<span class="comment">(* custom coinduction theorem (getting rid of rel_fun) *)</span>
<span class="command">declare</span> language.coinduct<span class="delimiter">[</span>unfolded rel_fun_def<span class="delimiter">,</span> simplified<span class="delimiter">,</span> case_names Lang<span class="delimiter">,</span> coinduct pred<span class="delimiter">]</span>
<span class="comment">(*&gt;*)</span>

<span class="command">section</span> <span class="verbatim">{* Regular Languages *}</span>

<span class="command">primcorec</span> Zero <span class="delimiter">::</span> <span class="string">&quot;&#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; Zero = False&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; Zero = (&lambda;_. Zero)&quot;</span>

<span class="command">primcorec</span> One <span class="delimiter">::</span> <span class="string">&quot;&#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; One = True&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; One = (&lambda;_. Zero)&quot;</span>

<span class="command">primcorec</span> Atom <span class="delimiter">::</span> <span class="string">&quot;&#39;a =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; (Atom a) = False&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; (Atom a) = (&lambda;b. if a = b then One else Zero)&quot;</span>

<span class="command">primcorec</span> Plus <span class="delimiter">::</span> <span class="string">&quot;&#39;a language =&gt; &#39;a language =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; (Plus r s) = (\&lt;oo&gt; r &or; \&lt;oo&gt; s)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; (Plus r s) = (&lambda;a. Plus (\&lt;dd&gt; r a) (\&lt;dd&gt; s a))&quot;</span>

<span class="command">theorem</span> Plus_ZeroL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Plus Zero r = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> simp

<span class="command">theorem</span> Plus_ZeroR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Plus r Zero = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> simp

<span class="command">theorem</span> Plus_assoc<span class="delimiter">:</span> <span class="string">&quot;Plus (Plus r s) t = Plus r (Plus s t)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s t<span class="delimiter">)</span> auto

<span class="command">theorem</span> Plus_comm<span class="delimiter">:</span> <span class="string">&quot;Plus r s = Plus s r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s<span class="delimiter">)</span> auto

<span class="command">lemma</span> Plus_rotate<span class="delimiter">:</span> <span class="string">&quot;Plus r (Plus s t) = Plus s (Plus r t)&quot;</span>
  <span class="command">using</span> Plus_assoc Plus_comm <span class="command">by</span> metis

<span class="command">theorem</span> Plus_idem<span class="delimiter">:</span> <span class="string">&quot;Plus r r = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Plus_idem_assoc<span class="delimiter">:</span> <span class="string">&quot;Plus r (Plus r s) = Plus r s&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis Plus_assoc Plus_idem<span class="delimiter">)</span>

<span class="command">lemmas</span> Plus_ACI<span class="delimiter">[</span>simp<span class="delimiter">]</span> <span class="delimiter">=</span> Plus_rotate Plus_comm Plus_assoc Plus_idem_assoc Plus_idem

<span class="command">text</span> <span class="verbatim">{*
  Coinduction up-to @{term Plus}--congruence relaxes the coinduction hypothesis by requiring
  membership in the congruence closure of the bisimulation rather than in the bisimulation itself.
*}</span>

<span class="command">inductive</span> Plus_cong <span class="keyword2">where</span>
  Refl<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Plus_cong R x x&quot;</span>
<span class="delimiter">|</span> Base<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;R x y ==&gt; Plus_cong R x y&quot;</span>
<span class="delimiter">|</span> Plus<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|Plus_cong R x y; Plus_cong R x&#39; y&#39;|] ==&gt; Plus_cong R (Plus x x&#39;) (Plus y y&#39;)&quot;</span>

<span class="command">lemma</span> language_coinduct_upto_Plus<span class="delimiter">[</span>unfolded rel_fun_def<span class="delimiter">,</span> simplified<span class="delimiter">,</span> case_names Lang<span class="delimiter">,</span> consumes 1<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> R<span class="delimiter">:</span> <span class="string">&quot;R L K&quot;</span> <span class="keyword2">and</span> hyp<span class="delimiter">:</span>
    <span class="string">&quot;(!!L K. R L K ==&gt; \&lt;oo&gt; L = \&lt;oo&gt; K &and; rel_fun op = (Plus_cong R) (\&lt;dd&gt; L) (\&lt;dd&gt; K))&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;L = K&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>coinduct rule<span class="delimiter">:</span> language.coinduct<span class="delimiter">[</span>of <span class="string">&quot;Plus_cong R&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">fix</span> L K <span class="command">assume</span> <span class="string">&quot;Plus_cong R L K&quot;</span>
  <span class="command">then</span> <span class="command">show</span> <span class="string">&quot;\&lt;oo&gt; L = \&lt;oo&gt; K &and; rel_fun op = (Plus_cong R) (\&lt;dd&gt; L) (\&lt;dd&gt; K)&quot;</span> <span class="command">using</span> hyp
    <span class="command">by</span> <span class="delimiter">(</span>induct rule<span class="delimiter">:</span> Plus_cong.induct<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> rel_fun_def<span class="delimiter">)</span>
<span class="command">qed</span> <span class="delimiter">(</span>intro Base R<span class="delimiter">)</span>

<span class="command">lemma</span> Plus_OneL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; r ==&gt; Plus One r = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> auto

<span class="command">lemma</span> Plus_OneR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; r ==&gt; Plus r One = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> auto

<span class="command">text</span> <span class="verbatim">{*
  Concatenation is not primitively corecursive---the corecursive call of its derivative is
  guarded by @{term Plus}. However, it can be defined as a composition of two primitively
  corecursive functions.
*}</span>

<span class="command">primcorec</span> TimesLR <span class="delimiter">::</span> <span class="string">&quot;&#39;a language =&gt; &#39;a language =&gt; (&#39;a &times; bool) language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; (TimesLR r s) = (\&lt;oo&gt; r &and; \&lt;oo&gt; s)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; (TimesLR r s) = (&lambda;(r, s). TimesLR r s) o (&lambda;(a, b). 
   (if b then (\&lt;dd&gt; r a, s) else if \&lt;oo&gt; r then (\&lt;dd&gt; s a, One) else (Zero, One)))&quot;</span>

<span class="command">primcorec</span> Times_Plus <span class="delimiter">::</span> <span class="string">&quot;(&#39;a &times; bool) language =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; (Times_Plus r) = \&lt;oo&gt; r&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; (Times_Plus r) = (&lambda;a. Times_Plus (Plus (\&lt;dd&gt; r (a, True)) (\&lt;dd&gt; r (a, False))))&quot;</span>

<span class="command">lemma</span> TimesLR_ZeroL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;TimesLR Zero r = Zero&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> TimesLR_ZeroR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;TimesLR r Zero = Zero&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> exI<span class="delimiter">[</span>of _ Zero<span class="delimiter">]</span><span class="delimiter">)</span>

<span class="command">lemma</span> TimesLR_PlusL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;TimesLR (Plus r s) t = Plus (TimesLR r t) (TimesLR s t)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s t rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> auto

<span class="command">lemma</span> TimesLR_PlusR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;TimesLR r (Plus s t) = Plus (TimesLR r s) (TimesLR r t)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s t rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> auto

<span class="command">lemma</span> Times_Plus_Zero<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times_Plus Zero = Zero&quot;</span>
  <span class="command">by</span> coinduction simp

<span class="command">lemma</span> Times_Plus_Plus<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times_Plus (Plus r s) = Plus (Times_Plus r) (Times_Plus s)&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s<span class="delimiter">)</span>
  <span class="command">case</span> <span class="delimiter">(</span>Lang r s<span class="delimiter">)</span>
  <span class="command">then</span> <span class="command">show</span> <span class="var">?case</span> <span class="command">unfolding</span> Times_Plus.sel Plus.sel
    <span class="command">by</span> <span class="delimiter">(</span>intro conjI<span class="delimiter">[</span>OF refl<span class="delimiter">]</span> allI exI conjI<span class="delimiter">[</span>rotated<span class="delimiter">]</span><span class="delimiter">,</span> rule refl<span class="delimiter">)</span> <span class="delimiter">(</span>metis Plus_comm Plus_rotate<span class="delimiter">)</span> 
<span class="command">qed</span>

<span class="command">lemma</span> Times_Plus_TimesLR_One<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times_Plus (TimesLR r One) = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> simp

<span class="command">lemma</span> Times_Plus_TimesLR_PlusL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span>
  <span class="string">&quot;Times_Plus (TimesLR (Plus r s) t) = Plus (Times_Plus (TimesLR r t)) (Times_Plus (TimesLR s t))&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s t rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> auto

<span class="command">lemma</span> Times_Plus_TimesLR_PlusR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span>
  <span class="string">&quot;Times_Plus (TimesLR r (Plus s t)) = Plus (Times_Plus (TimesLR r s)) (Times_Plus (TimesLR r t))&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s t rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> auto

<span class="command">definition</span> Times <span class="delimiter">::</span> <span class="string">&quot;&#39;a language =&gt; &#39;a language =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;Times r s = Times_Plus (TimesLR r s)&quot;</span>

<span class="command">lemma</span> \&lt;oo&gt;_Times<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span>
  <span class="string">&quot;\&lt;oo&gt; (Times r s) = (\&lt;oo&gt; r &and; \&lt;oo&gt; s)&quot;</span>
  <span class="command">unfolding</span> Times_def <span class="command">by</span> simp

<span class="command">lemma</span> \&lt;dd&gt;_Times<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span>
  <span class="string">&quot;\&lt;dd&gt; (Times r s) = (&lambda;a. if \&lt;oo&gt; r then Plus (Times (\&lt;dd&gt; r a) s) (\&lt;dd&gt; s a) else Times (\&lt;dd&gt; r a) s)&quot;</span>
  <span class="command">unfolding</span> Times_def <span class="command">by</span> <span class="delimiter">(</span>rule ext<span class="delimiter">,</span> coinduction arbitrary<span class="delimiter">:</span> r s rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> auto

<span class="command">theorem</span> Times_ZeroL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times Zero r = Zero&quot;</span>
  <span class="command">by</span> coinduction simp

<span class="command">theorem</span> Times_ZeroR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times r Zero = Zero&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">theorem</span> Times_OneL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times One r = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r rule<span class="delimiter">:</span> language.strong_coinduct<span class="delimiter">)</span> <span class="delimiter">(</span>simp add<span class="delimiter">:</span> rel_fun_def<span class="delimiter">)</span>

<span class="command">theorem</span> Times_OneR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times r One = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> simp

<span class="command">theorem</span> Times_PlusL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times (Plus r s) t = Plus (Times r t) (Times s t)&quot;</span>
  <span class="command">unfolding</span> Times_def <span class="command">by</span> simp

<span class="command">theorem</span> Times_PlusR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times r (Plus s t) = Plus (Times r s) (Times r t)&quot;</span>
  <span class="command">unfolding</span> Times_def <span class="command">by</span> simp

<span class="command">theorem</span> Times_assoc<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times (Times r s) t = Times r (Times s t)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s t rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> fastforce

<span class="command">text</span> <span class="verbatim">{*
  Similarly to @{term Times}, iteration is not primitively corecursive (guardedness by
  @{term Times} is required). We apply a similar trick to obtain its definition.
*}</span>

<span class="command">primcorec</span> StarLR <span class="delimiter">::</span> <span class="string">&quot;&#39;a language =&gt; &#39;a language =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; (StarLR r s) = \&lt;oo&gt; r&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; (StarLR r s) = (&lambda;a. StarLR (\&lt;dd&gt; (Times r (Plus One s)) a) s)&quot;</span>

<span class="command">lemma</span> StarLR_Zero<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;StarLR Zero r = Zero&quot;</span>
  <span class="command">by</span> coinduction auto

<span class="command">lemma</span> StarLR_Plus<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;StarLR (Plus r s) t = Plus (StarLR r t) (StarLR s t)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp del<span class="delimiter">:</span> Plus_ACI Times_PlusR<span class="delimiter">)</span>

<span class="command">lemma</span> StarLR_Times_Plus_One<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;StarLR (Times r (Plus One s)) s = StarLR r s&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s<span class="delimiter">)</span>
  <span class="command">case</span> Lang
  <span class="command">{</span> <span class="command">fix</span> a
    <span class="command">def</span> L <span class="delimiter">&equiv;</span> <span class="string">&quot;Plus (\&lt;dd&gt; r a) (Plus (Times (\&lt;dd&gt; r a) s) (\&lt;dd&gt; s a))&quot;</span>
    <span class="keyword2">and</span> R <span class="delimiter">&equiv;</span> <span class="string">&quot;Times (Plus (\&lt;dd&gt; r a) (Plus (Times (\&lt;dd&gt; r a) s) (\&lt;dd&gt; s a))) s&quot;</span>
    <span class="command">have</span> <span class="string">&quot;Plus L (Plus R (\&lt;dd&gt; s a)) = Plus (Plus L (\&lt;dd&gt; s a)) R&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>metis Plus_assoc Plus_comm<span class="delimiter">)</span>
    <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;Plus L (\&lt;dd&gt; s a) = L&quot;</span> <span class="command">unfolding</span> L_def <span class="command">by</span> simp
    <span class="command">finally</span> <span class="command">have</span> <span class="string">&quot;Plus L (Plus R (\&lt;dd&gt; s a)) = Plus L R&quot;</span> <span class="command">.</span>
  <span class="command">}</span>
  <span class="command">then</span> <span class="command">show</span> <span class="var">?case</span> <span class="command">by</span> <span class="delimiter">(</span>auto simp del<span class="delimiter">:</span> StarLR_Plus Plus_assoc Times_PlusL<span class="delimiter">)</span>
<span class="command">qed</span>

<span class="command">lemma</span> StarLR_Times<span class="delimiter">:</span> <span class="string">&quot;StarLR (Times r s) t = Times r (StarLR s t)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s t rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span>
    <span class="delimiter">(</span>fastforce simp del<span class="delimiter">:</span> Plus_ACI Times_PlusR<span class="delimiter">)</span>

<span class="command">definition</span> Star <span class="delimiter">::</span> <span class="string">&quot;&#39;a language =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;Star r = StarLR One r&quot;</span>

<span class="command">lemma</span> \&lt;oo&gt;_Star<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; (Star r)&quot;</span>
  <span class="command">unfolding</span> Star_def <span class="command">by</span> simp

<span class="command">lemma</span> \&lt;dd&gt;_Star<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;\&lt;dd&gt; (Star r) = (&lambda;a. Times (\&lt;dd&gt; r a) (Star r))&quot;</span>
  <span class="command">unfolding</span> Star_def <span class="command">by</span> <span class="delimiter">(</span>rule ext<span class="delimiter">,</span> coinduction arbitrary<span class="delimiter">:</span> r rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span>
    <span class="delimiter">(</span>auto simp add<span class="delimiter">:</span> Star_def StarLR_Times<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>

<span class="command">lemma</span> Star_Zero<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Star Zero = One&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction rule<span class="delimiter">:</span> language.strong_coinduct<span class="delimiter">)</span> auto

<span class="command">lemma</span> Star_One<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Star One = One&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction rule<span class="delimiter">:</span> language.strong_coinduct<span class="delimiter">)</span> auto

<span class="command">lemma</span> Star_unfoldL<span class="delimiter">:</span> <span class="string">&quot;Star r = Plus One (Times r (Star r))&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r rule<span class="delimiter">:</span> language_coinduct_upto_Plus<span class="delimiter">)</span> auto

<span class="command">primcorec</span> Inter <span class="delimiter">::</span> <span class="string">&quot;&#39;a language =&gt; &#39;a language =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; (Inter r s) = (\&lt;oo&gt; r &and; \&lt;oo&gt; s)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; (Inter r s) = (&lambda;a. Inter (\&lt;dd&gt; r a) (\&lt;dd&gt; s a))&quot;</span>

<span class="command">primcorec</span> Not <span class="delimiter">::</span> <span class="string">&quot;&#39;a language =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; (Not r) = (&not; \&lt;oo&gt; r)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; (Not r) = (&lambda;a. Not (\&lt;dd&gt; r a))&quot;</span>

<span class="command">primcorec</span> Full <span class="delimiter">::</span> <span class="string">&quot;&#39;a language&quot;</span> <span class="delimiter">(</span><span class="string">&quot;&Sigma;<span class="hidden">&#8679;</span><sup>*</sup>&quot;</span><span class="delimiter">)</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; Full = True&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; Full = (&lambda;_. Full)&quot;</span>

<span class="command">text</span> <span class="verbatim">{*
  We generalize coinduction up-to @{term Plus} to coinduction up-to all previously defined concepts.
*}</span>

<span class="command">inductive</span> regular_cong <span class="keyword2">where</span>
  Refl<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;regular_cong R x x&quot;</span>
<span class="delimiter">|</span> Sym<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;regular_cong R x y ==&gt; regular_cong R y x&quot;</span>
<span class="delimiter">|</span> Trans<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|regular_cong R x y; regular_cong R y z|] ==&gt; regular_cong R x z&quot;</span>
<span class="delimiter">|</span> Base<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;R x y ==&gt; regular_cong R x y&quot;</span>
<span class="delimiter">|</span> Plus<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|regular_cong R x y; regular_cong R x&#39; y&#39;|] ==&gt;
    regular_cong R (Plus x x&#39;) (Plus y y&#39;)&quot;</span>
<span class="delimiter">|</span> Times<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|regular_cong R x y; regular_cong R x&#39; y&#39;|] ==&gt;
    regular_cong R (Times x x&#39;) (Times y y&#39;)&quot;</span>
<span class="delimiter">|</span> Star<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|regular_cong R x y|] ==&gt;
    regular_cong R (Star x) (Star y)&quot;</span>
<span class="delimiter">|</span> Inter<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|regular_cong R x y; regular_cong R x&#39; y&#39;|] ==&gt;
    regular_cong R (Inter x x&#39;) (Inter y y&#39;)&quot;</span>
<span class="delimiter">|</span> Not<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|regular_cong R x y|] ==&gt;
    regular_cong R (Not x) (Not y)&quot;</span>

<span class="command">lemma</span> language_coinduct_upto_regular<span class="delimiter">[</span>unfolded rel_fun_def<span class="delimiter">,</span> simplified<span class="delimiter">,</span> case_names Lang<span class="delimiter">,</span> consumes 1<span class="delimiter">]</span><span class="delimiter">:</span> 
  <span class="keyword2">assumes</span> R<span class="delimiter">:</span> <span class="string">&quot;R L K&quot;</span> <span class="keyword2">and</span> hyp<span class="delimiter">:</span>
    <span class="string">&quot;(!!L K. R L K ==&gt; \&lt;oo&gt; L = \&lt;oo&gt; K &and; rel_fun op = (regular_cong R) (\&lt;dd&gt; L) (\&lt;dd&gt; K))&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;L = K&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>coinduct rule<span class="delimiter">:</span> language.coinduct<span class="delimiter">[</span>of <span class="string">&quot;regular_cong R&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">fix</span> L K <span class="command">assume</span> <span class="string">&quot;regular_cong R L K&quot;</span>
  <span class="command">then</span> <span class="command">show</span> <span class="string">&quot;\&lt;oo&gt; L = \&lt;oo&gt; K &and; rel_fun op = (regular_cong R) (\&lt;dd&gt; L) (\&lt;dd&gt; K)&quot;</span> <span class="command">using</span> hyp
    <span class="command">by</span> <span class="delimiter">(</span>induct rule<span class="delimiter">:</span> regular_cong.induct<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> rel_fun_def<span class="delimiter">)</span>
<span class="command">qed</span> <span class="delimiter">(</span>intro Base R<span class="delimiter">)</span>

<span class="command">lemma</span> Star_unfoldR<span class="delimiter">:</span> <span class="string">&quot;Star r = Plus One (Times (Star r) r)&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r rule<span class="delimiter">:</span> language_coinduct_upto_regular<span class="delimiter">)</span>
  <span class="command">case</span> Lang
  <span class="command">{</span> <span class="command">fix</span> a <span class="command">have</span> <span class="string">&quot;Plus (Times (\&lt;dd&gt; r a) (Times (Star r) r)) (\&lt;dd&gt; r a) = 
      Times (\&lt;dd&gt; r a) (Plus One (Times (Star r) r))&quot;</span> <span class="command">by</span> simp
  <span class="command">}</span>
  <span class="command">then</span> <span class="command">show</span> <span class="var">?case</span> <span class="command">by</span> <span class="delimiter">(</span>auto simp del<span class="delimiter">:</span> Times_PlusR<span class="delimiter">)</span>
<span class="command">qed</span>

<span class="command">lemma</span> Star_Star<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Star (Star r) = Star r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>subst Star_unfoldL<span class="delimiter">,</span> coinduction arbitrary<span class="delimiter">:</span> r rule<span class="delimiter">:</span> language_coinduct_upto_regular<span class="delimiter">)</span> auto

<span class="command">lemma</span> Times_Star<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Times (Star r) (Star r) = Star r&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r rule<span class="delimiter">:</span> language_coinduct_upto_regular<span class="delimiter">)</span>
  <span class="command">case</span> Lang
  <span class="command">have</span> *<span class="delimiter">:</span> <span class="string">&quot;!!r s. Plus (Times r s) r = Times r (Plus s One)&quot;</span> <span class="command">by</span> simp
  <span class="command">show</span> <span class="var">?case</span> <span class="command">by</span> <span class="delimiter">(</span>auto simp del<span class="delimiter">:</span> Times_PlusR Plus_ACI simp<span class="delimiter">:</span> Times_PlusR<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> *<span class="delimiter">)</span>
<span class="command">qed</span>

<span class="command">instantiation</span> language <span class="delimiter">::</span> <span class="delimiter">(</span>type<span class="delimiter">)</span> <span class="string">&quot;{semiring_1, order}&quot;</span>
<span class="keyword2">begin</span>

<span class="command">lemma</span> Zero_One<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Zero &ne; One&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis One.simps<span class="delimiter">(</span>1<span class="delimiter">)</span> Zero.simps<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>

<span class="command">definition</span> <span class="string">&quot;zero_language = Zero&quot;</span>
<span class="command">definition</span> <span class="string">&quot;one_language = One&quot;</span>
<span class="command">definition</span> <span class="string">&quot;plus_language = Plus&quot;</span>
<span class="command">definition</span> <span class="string">&quot;times_language = Times&quot;</span>

<span class="command">definition</span> <span class="string">&quot;less_eq_language r s = (Plus r s = s)&quot;</span>
<span class="command">definition</span> <span class="string">&quot;less_language r s = (Plus r s = s &and; r &ne; s)&quot;</span>

<span class="command">lemmas</span> language_defs <span class="delimiter">=</span> zero_language_def one_language_def plus_language_def times_language_def
  less_eq_language_def less_language_def

<span class="command">instance</span> <span class="command">proof</span> intro_classes
  <span class="command">fix</span> x y z <span class="delimiter">::</span> <span class="string">&quot;&#39;a language&quot;</span> <span class="command">assume</span> <span class="string">&quot;x &le; y&quot;</span> <span class="string">&quot;y &le; z&quot;</span>
  <span class="command">then</span> <span class="command">show</span> <span class="string">&quot;x &le; z&quot;</span> <span class="command">unfolding</span> language_defs <span class="command">by</span> <span class="delimiter">(</span>metis Plus_assoc<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> x y z <span class="delimiter">::</span> <span class="string">&quot;&#39;a language&quot;</span>
  <span class="command">show</span> <span class="string">&quot;x + y + z = x + (y + z)&quot;</span> <span class="command">unfolding</span> language_defs <span class="command">by</span> <span class="delimiter">(</span>rule Plus_assoc<span class="delimiter">)</span>
<span class="command">qed</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> language_defs<span class="delimiter">)</span>

<span class="command">end</span>

<span class="command">text</span> <span class="verbatim">{*
  We prove the missing axioms of Kleene Algebras about @{term Star}, as well as monotonicity
  properties and three standard interesting rules: bisimulation, sliding, and denesting.
*}</span>

<span class="command">theorem</span> le_StarL<span class="delimiter">:</span> <span class="string">&quot;Plus One (Times r (Star r)) &le; Star r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>rule order_eq_refl<span class="delimiter">[</span>OF Star_unfoldL<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>

<span class="command">theorem</span> le_StarR<span class="delimiter">:</span> <span class="string">&quot;Plus One (Times (Star r) r) &le; Star r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>rule order_eq_refl<span class="delimiter">[</span>OF Star_unfoldR<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>

<span class="command">theorem</span> ardenL<span class="delimiter">:</span> <span class="string">&quot;Plus r (Times s x) &le; x ==&gt; Times (Star s) r &le; x&quot;</span>
<span class="command">unfolding</span> language_defs
<span class="command">proof</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s x rule<span class="delimiter">:</span> language_coinduct_upto_regular<span class="delimiter">)</span>
  <span class="command">case</span> Lang
  <span class="command">hence</span> <span class="string">&quot;\&lt;oo&gt; r ==&gt; \&lt;oo&gt; x&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>metis Plus.sel<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="command">moreover</span>
  <span class="command">{</span> <span class="command">fix</span> a
    <span class="command">let</span> <span class="var">?R</span> <span class="delimiter">=</span> <span class="string">&quot;(&lambda;L K. &exist;r s.  L = Plus (Times (Star s) r) K &and; Plus r (Plus (Times s K) K) = K)&quot;</span>
    <span class="command">have</span> <span class="string">&quot;regular_cong ?R (Plus x (Times (Star s) r)) x&quot;</span>
      <span class="command">using</span> Lang<span class="delimiter">[</span>unfolded Plus_assoc<span class="delimiter">]</span> <span class="command">by</span> <span class="delimiter">(</span>auto simp only<span class="delimiter">:</span> Plus_comm<span class="delimiter">)</span>
    <span class="command">hence</span> <span class="string">&quot;regular_cong ?R
      (Plus (Times (\&lt;dd&gt; s a) (Plus x (Times (Star s) r))) (Plus (\&lt;dd&gt; r a) (\&lt;dd&gt; x a)))
      (Plus (\&lt;dd&gt; r a) (Plus (Times (\&lt;dd&gt; s a) x) (\&lt;dd&gt; x a)))&quot;</span>
      <span class="command">by</span> <span class="delimiter">(</span>auto simp del<span class="delimiter">:</span> Times_PlusR<span class="delimiter">)</span>
    <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;(Plus (Times (\&lt;dd&gt; s a) (Plus x (Times (Star s) r))) (Plus (\&lt;dd&gt; r a) (\&lt;dd&gt; x a))) = 
      (Plus (Times (\&lt;dd&gt; s a) (Times (Star s) r)) (Plus (\&lt;dd&gt; r a) (\&lt;dd&gt; x a)))&quot;</span>
      <span class="command">by</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>3<span class="delimiter">)</span> Lang<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> auto
    <span class="command">finally</span> <span class="command">have</span> <span class="string">&quot;regular_cong ?R
      (Plus (Times (\&lt;dd&gt; s a) (Times (Star s) r)) (Plus (\&lt;dd&gt; r a) (\&lt;dd&gt; x a)))
      (Plus (\&lt;dd&gt; r a) (Plus (Times (\&lt;dd&gt; s a) x) (\&lt;dd&gt; x a)))&quot;</span> <span class="command">.</span>
  <span class="command">}</span>
  <span class="command">ultimately</span> <span class="command">show</span> <span class="var">?case</span> <span class="command">by</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>4<span class="delimiter">)</span> Lang<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> auto
<span class="command">qed</span>

<span class="command">theorem</span> ardenR<span class="delimiter">:</span> <span class="string">&quot;Plus r (Times x s) &le; x ==&gt; Times r (Star s) &le; x&quot;</span>
<span class="command">unfolding</span> language_defs
<span class="command">proof</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s x rule<span class="delimiter">:</span> language_coinduct_upto_regular<span class="delimiter">)</span>
  <span class="command">case</span> Lang
  <span class="command">let</span> <span class="var">?R</span> <span class="delimiter">=</span> <span class="string">&quot;(&lambda;L K. &exist;r s. L = Plus (Times r (Star s)) K &and; Plus r (Plus (Times K s) K) = K)&quot;</span>
  <span class="command">have</span> <span class="string">&quot;!!a. \&lt;oo&gt; x ==&gt; Plus (\&lt;dd&gt; s a) (\&lt;dd&gt; x a) = \&lt;dd&gt; x a&quot;</span>
    <span class="command">by</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>1 2<span class="delimiter">)</span> Lang<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> auto
  <span class="command">then</span> <span class="command">have</span> *<span class="delimiter">:</span> <span class="string">&quot;!!a. ?R (Plus (Times (\&lt;dd&gt; r a) (Star s)) (\&lt;dd&gt; x a)) (\&lt;dd&gt; x a)&quot;</span>
    <span class="command">by</span> <span class="delimiter">(</span>subst Lang<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">(</span>auto simp del<span class="delimiter">:</span> Plus_comm<span class="delimiter">)</span>
  <span class="command">moreover</span>
  <span class="command">from</span> Lang <span class="command">have</span> <span class="string">&quot;\&lt;oo&gt; r ==&gt; \&lt;oo&gt; x&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>metis Plus.sel<span class="delimiter">(</span>1<span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="command">moreover</span>
  <span class="command">{</span> <span class="command">fix</span> a <span class="command">assume</span> <span class="string">&quot;\&lt;oo&gt; x&quot;</span>
    <span class="command">have</span> <span class="string">&quot;regular_cong ?R (Plus (Times (\&lt;dd&gt; s a) (Star s)) (\&lt;dd&gt; x a)) (\&lt;dd&gt; x a)&quot;</span>
    <span class="command">proof</span> <span class="delimiter">(</span>rule Base exI conjI<span class="delimiter">[</span>OF refl<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span>
      <span class="command">from</span> <span class="altstring">`\&lt;oo&gt; x`</span> <span class="command">show</span> <span class="string">&quot;Plus (\&lt;dd&gt; s a) (Plus (Times (\&lt;dd&gt; x a) s) (\&lt;dd&gt; x a)) = \&lt;dd&gt; x a&quot;</span>
        <span class="command">by</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>1 3<span class="delimiter">)</span> Lang<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> auto
    <span class="command">qed</span>
    <span class="command">from</span> Plus<span class="delimiter">[</span>OF Base<span class="delimiter">[</span>of <span class="var">?R</span><span class="delimiter">,</span> OF *<span class="delimiter">[</span>of a<span class="delimiter">]</span><span class="delimiter">]</span> this<span class="delimiter">]</span> <span class="command">have</span> <span class="string">&quot;regular_cong ?R
      (Plus (Times (\&lt;dd&gt; r a) (Star s)) (Plus (Times (\&lt;dd&gt; s a) (Star s)) (\&lt;dd&gt; x a))) (\&lt;dd&gt; x a)&quot;</span> <span class="command">by</span> auto
  <span class="command">}</span>
  <span class="command">ultimately</span> <span class="command">show</span> <span class="var">?case</span> <span class="command">by</span> auto
<span class="command">qed</span>

<span class="command">lemma</span> ge_One<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;One &le; r &lt;-&gt; \&lt;oo&gt; r&quot;</span>
  <span class="command">unfolding</span> less_eq_language_def <span class="command">by</span> <span class="delimiter">(</span>metis One.sel<span class="delimiter">(</span>1<span class="delimiter">)</span> Plus.sel<span class="delimiter">(</span>1<span class="delimiter">)</span> Plus_OneL<span class="delimiter">)</span>

<span class="command">lemma</span> Plus_mono<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|r1 &le; s1; r2 &le; s2|] ==&gt; Plus r1 r2 &le; Plus s1 s2&quot;</span>
  <span class="command">unfolding</span> less_eq_language_def <span class="command">by</span> <span class="delimiter">(</span>metis Plus_assoc Plus_comm<span class="delimiter">)</span>

<span class="command">lemma</span> Plus_upper<span class="delimiter">:</span> <span class="string">&quot;[|r1 &le; s; r2 &le; s|] ==&gt; Plus r1 r2 &le; s&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis Plus_mono Plus_idem<span class="delimiter">)</span>

<span class="command">lemma</span> le_PlusL<span class="delimiter">:</span> <span class="string">&quot;r &le; Plus r s&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis Plus_idem_assoc less_eq_language_def<span class="delimiter">)</span>

<span class="command">lemma</span> le_PlusR<span class="delimiter">:</span> <span class="string">&quot;s &le; Plus r s&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis Plus_comm Plus_idem_assoc less_eq_language_def<span class="delimiter">)</span>

<span class="command">lemma</span> Times_mono<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|r1 &le; s1; r2 &le; s2|] ==&gt; Times r1 r2 &le; Times s1 s2&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>unfold less_eq_language_def<span class="delimiter">)</span>
  <span class="command">assume</span> s1<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Plus r1 s1 = s1&quot;</span> <span class="keyword2">and</span> s2<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Plus r2 s2 = s2&quot;</span>
  <span class="command">have</span> <span class="string">&quot;Plus (Times r1 r2) (Times s1 s2) =
    Plus (Times r1 r2) (Plus (Times r1 r2) (Plus (Times s1 r2) (Plus (Times r1 s2) (Times s1 s2))))&quot;</span>
    <span class="command">by</span> <span class="delimiter">(</span>subst s1<span class="delimiter">,</span> subst s2<span class="delimiter">)</span> auto
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; = Plus (Times r1 r2) (Plus (Times s1 r2) (Plus (Times r1 s2) (Times s1 s2)))&quot;</span>
    <span class="command">by</span> <span class="delimiter">(</span>metis Plus_idem Plus_assoc<span class="delimiter">)</span>
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; = Times s1 s2&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>subst s1<span class="delimiter">,</span> subst s2<span class="delimiter">)</span> auto
  <span class="command">finally</span> <span class="command">show</span> <span class="string">&quot;Plus (Times r1 r2) (Times s1 s2) = Times s1 s2&quot;</span> <span class="command">.</span>
<span class="command">qed</span>

<span class="command">lemma</span> le_TimesL<span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; s ==&gt; r &le; Times r s&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis Plus_OneL Times_OneR Times_mono le_PlusL order_refl<span class="delimiter">)</span>

<span class="command">lemma</span> le_TimesR<span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; r ==&gt; s &le; Times r s&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis Plus_OneR Times_OneL Times_mono le_PlusR order_refl<span class="delimiter">)</span>

<span class="command">lemma</span> le_Star<span class="delimiter">:</span> <span class="string">&quot;s &le; Star s&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>subst Star_unfoldL<span class="delimiter">,</span> subst Star_unfoldL<span class="delimiter">)</span> <span class="delimiter">(</span>auto intro<span class="delimiter">:</span> order_trans<span class="delimiter">[</span>OF le_PlusL le_PlusR<span class="delimiter">]</span><span class="delimiter">)</span>

<span class="command">lemma</span> Star_mono<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> rs<span class="delimiter">:</span> <span class="string">&quot;r &le; s&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;Star r &le; Star s&quot;</span>
<span class="command">proof</span> -
  <span class="command">have</span> <span class="string">&quot;Star r = Plus One (Times (Star r) r)&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>rule Star_unfoldR<span class="delimiter">)</span>
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; &le; Plus One (Times (Star r) s)&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>blast intro<span class="delimiter">:</span> rs<span class="delimiter">)</span>
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;Times (Star r) s &le; Star s&quot;</span>
  <span class="command">proof</span> <span class="delimiter">(</span>rule ardenL<span class="delimiter">[</span>OF Plus_upper<span class="delimiter">[</span>OF le_Star<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="command">have</span> <span class="string">&quot;Times r (Star s) &le; Times s (Star s)&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>blast intro<span class="delimiter">:</span> rs<span class="delimiter">)</span>
    <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;Times s (Star s) &le; Plus One (Times s (Star s))&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>rule le_PlusR<span class="delimiter">)</span>
    <span class="command">finally</span> <span class="command">show</span> <span class="string">&quot;Times r (Star s) &le; Star s&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>2<span class="delimiter">)</span> Star_unfoldL<span class="delimiter">)</span>
  <span class="command">qed</span>
  <span class="command">finally</span> <span class="command">show</span> <span class="var">?thesis</span> <span class="command">by</span> auto
<span class="command">qed</span>

<span class="command">lemma</span> Inter_mono<span class="delimiter">:</span> <span class="string">&quot;[|r1 &le; s1; r2 &le; s2|] ==&gt; Inter r1 r2 &le; Inter s1 s2&quot;</span>
<span class="command">unfolding</span> less_eq_language_def <span class="command">proof</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r1 r2 s1 s2<span class="delimiter">)</span>
  <span class="command">case</span> Lang
  <span class="command">then</span> <span class="command">have</span> <span class="string">&quot;\&lt;oo&gt; (Plus r1 s1) = \&lt;oo&gt; s1&quot;</span> <span class="string">&quot;\&lt;oo&gt; (Plus r2 s2) = \&lt;oo&gt; s2&quot;</span>
        <span class="string">&quot;&forall;a. \&lt;dd&gt; (Plus r1 s1) a = \&lt;dd&gt; s1 a&quot;</span> <span class="string">&quot;&forall;a. \&lt;dd&gt; (Plus r2 s2) a = \&lt;dd&gt; s2 a&quot;</span> <span class="command">by</span> simp_all
  <span class="command">then</span> <span class="command">show</span> <span class="var">?case</span> <span class="command">by</span> fastforce
<span class="command">qed</span>

<span class="command">lemma</span> Not_antimono<span class="delimiter">:</span> <span class="string">&quot;r &le; s ==&gt; Not s &le; Not r&quot;</span>
<span class="command">unfolding</span> less_eq_language_def <span class="command">proof</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s<span class="delimiter">)</span>
  <span class="command">case</span> Lang
  <span class="command">then</span> <span class="command">have</span> <span class="string">&quot;\&lt;oo&gt; (Plus r s) = \&lt;oo&gt; s&quot;</span> <span class="string">&quot;&forall;a. \&lt;dd&gt; (Plus r s) a = \&lt;dd&gt; s a&quot;</span> <span class="command">by</span> simp_all
  <span class="command">then</span> <span class="command">show</span> <span class="var">?case</span> <span class="command">by</span> auto
<span class="command">qed</span>

<span class="command">lemma</span> Not_Plus<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Not (Plus r s) = Inter (Not r) (Not s)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s<span class="delimiter">)</span> auto

<span class="command">lemma</span> Not_Inter<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Not (Inter r s) = Plus (Not r) (Not s)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s<span class="delimiter">)</span> auto

<span class="command">lemma</span> Inter_assoc<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Inter (Inter r s) t = Inter r (Inter s t)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s t<span class="delimiter">)</span> auto

<span class="command">lemma</span> Inter_comm<span class="delimiter">:</span> <span class="string">&quot;Inter r s = Inter s r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r s<span class="delimiter">)</span> auto

<span class="command">lemma</span> Inter_idem<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Inter r r = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Inter_ZeroL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Inter Zero r = Zero&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Inter_ZeroR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Inter r Zero = Zero&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Inter_FullL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Inter Full r = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Inter_FullR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Inter r Full = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Plus_FullL<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Plus Full r = Full&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Plus_FullR<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Plus r Full = Full&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Not_Not<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Not (Not r) = r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> r<span class="delimiter">)</span> auto

<span class="command">lemma</span> Not_Zero<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Not Zero = Full&quot;</span>
  <span class="command">by</span> coinduction simp

<span class="command">lemma</span> Not_Full<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Not Full = Zero&quot;</span>
  <span class="command">by</span> coinduction simp

<span class="command">lemma</span> bisimulation<span class="delimiter">:</span>
  <span class="keyword2">assumes</span> <span class="string">&quot;Times r s = Times s t&quot;</span>
  <span class="keyword2">shows</span> <span class="string">&quot;Times (Star r) s = Times s (Star t)&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>rule antisym<span class="delimiter">[</span>OF ardenL<span class="delimiter">[</span>OF Plus_upper<span class="delimiter">[</span>OF le_TimesL<span class="delimiter">]</span><span class="delimiter">]</span> ardenR<span class="delimiter">[</span>OF Plus_upper<span class="delimiter">[</span>OF le_TimesR<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">have</span> <span class="string">&quot;Times r (Times s (Star t)) = Times s (Times t (Star t))&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = _&quot;</span><span class="delimiter">)</span>
    <span class="command">by</span> <span class="delimiter">(</span>simp only<span class="delimiter">:</span> assms Times_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; &le; Times s (Star t)&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;_ &le; ?R&quot;</span><span class="delimiter">)</span>
    <span class="command">by</span> <span class="delimiter">(</span>rule Times_mono<span class="delimiter">[</span>OF order_refl ord_le_eq_trans<span class="delimiter">[</span>OF le_PlusR Star_unfoldL<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">finally</span> <span class="command">show</span> <span class="string">&quot;?L &le; ?R&quot;</span> <span class="command">.</span>
<span class="command">next</span>
  <span class="command">have</span> <span class="string">&quot;Times (Times (Star r) s) t = Times (Times (Star r) r) s&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = _&quot;</span><span class="delimiter">)</span>
    <span class="command">by</span> <span class="delimiter">(</span>simp only<span class="delimiter">:</span> assms Times_assoc<span class="delimiter">)</span>
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; &le; Times (Star r) s&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;_ &le; ?R&quot;</span><span class="delimiter">)</span>
    <span class="command">by</span> <span class="delimiter">(</span>rule Times_mono<span class="delimiter">[</span>OF ord_le_eq_trans<span class="delimiter">[</span>OF le_PlusR Star_unfoldR<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span> order_refl<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">finally</span> <span class="command">show</span> <span class="string">&quot;?L &le; ?R&quot;</span> <span class="command">.</span>
<span class="command">qed</span> simp_all

<span class="command">lemma</span> sliding<span class="delimiter">:</span> <span class="string">&quot;Times (Star (Times r s)) r = Times r (Star (Times s r))&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>rule antisym<span class="delimiter">[</span>OF ardenL<span class="delimiter">[</span>OF Plus_upper<span class="delimiter">[</span>OF le_TimesL<span class="delimiter">]</span><span class="delimiter">]</span> ardenR<span class="delimiter">[</span>OF Plus_upper<span class="delimiter">[</span>OF le_TimesR<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">have</span> <span class="string">&quot;Times (Times r s) (Times r (Star (Times s r))) =
    Times r (Times (Times s r) (Star (Times s r)))&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = _&quot;</span><span class="delimiter">)</span> <span class="command">by</span> simp
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; &le; Times r (Star (Times s r))&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;_ &le; ?R&quot;</span><span class="delimiter">)</span>
    <span class="command">by</span> <span class="delimiter">(</span>rule Times_mono<span class="delimiter">[</span>OF order_refl ord_le_eq_trans<span class="delimiter">[</span>OF le_PlusR Star_unfoldL<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">finally</span> <span class="command">show</span> <span class="string">&quot;?L &le; ?R&quot;</span> <span class="command">.</span>
<span class="command">next</span>
  <span class="command">have</span> <span class="string">&quot;Times (Times (Star (Times r s)) r) (Times s r) =
    Times (Times (Star (Times r s)) (Times r s)) r&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = _&quot;</span><span class="delimiter">)</span> <span class="command">by</span> simp
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; &le; Times (Star (Times r s)) r&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;_ &le; ?R&quot;</span><span class="delimiter">)</span>
    <span class="command">by</span> <span class="delimiter">(</span>rule Times_mono<span class="delimiter">[</span>OF ord_le_eq_trans<span class="delimiter">[</span>OF le_PlusR Star_unfoldR<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span> order_refl<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">finally</span> <span class="command">show</span> <span class="string">&quot;?L &le; ?R&quot;</span> <span class="command">.</span>
<span class="command">qed</span> simp_all

<span class="command">lemma</span> denesting<span class="delimiter">:</span> <span class="string">&quot;Star (Plus r s) = Times (Star r) (Star (Times s (Star r)))&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>rule antisym<span class="delimiter">[</span>OF _ ardenR<span class="delimiter">[</span>OF Plus_upper<span class="delimiter">[</span>OF Star_mono<span class="delimiter">[</span>OF le_PlusL<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">have</span> <span class="string">&quot;Star (Plus r s) = Times (Star (Plus r s)) One&quot;</span> <span class="command">by</span> simp
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; &le; Times (Star r) (Star (Times s (Star r)))&quot;</span>
  <span class="command">proof</span> <span class="delimiter">(</span>rule ardenL<span class="delimiter">[</span>OF Plus_upper<span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="command">show</span> <span class="string">&quot;Times (Plus r s) (Times (Star r) (Star (Times s (Star r)))) &le;
      Times (Star r) (Star (Times s (Star r)))&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;Times _ ?L &le; ?R&quot;</span><span class="delimiter">)</span>
    <span class="command">proof</span> <span class="delimiter">(</span>subst Times_PlusL<span class="delimiter">,</span> rule Plus_upper<span class="delimiter">)</span>
      <span class="command">show</span> <span class="string">&quot;Times s ?L &le; ?R&quot;</span>
        <span class="command">by</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>5<span class="delimiter">)</span> Star_unfoldL<span class="delimiter">,</span> rule order_trans<span class="delimiter">[</span>OF order_trans<span class="delimiter">[</span>OF _ le_PlusR<span class="delimiter">]</span> le_TimesR<span class="delimiter">]</span><span class="delimiter">)</span> auto
    <span class="command">qed</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>4<span class="delimiter">)</span> Times_Star<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> auto simp del<span class="delimiter">:</span> Times_Star intro<span class="delimiter">:</span> le_Star<span class="delimiter">)</span>
  <span class="command">qed</span> simp
  <span class="command">finally</span> <span class="command">show</span> <span class="string">&quot;Star (Plus r s) &le; Times (Star r) (Star (Times s (Star r)))&quot;</span> <span class="command">.</span>
<span class="command">next</span>
  <span class="command">have</span> <span class="string">&quot;Times (Star (Plus r s)) (Times s (Star r)) &le; Times (Star (Plus r s)) (Star (Plus r s))&quot;</span>
    <span class="command">by</span> <span class="delimiter">(</span>subst <span class="delimiter">(</span>4<span class="delimiter">)</span> Star_unfoldL<span class="delimiter">,</span> rule Times_mono<span class="delimiter">[</span>OF order_refl
      order_trans<span class="delimiter">[</span>OF Times_mono<span class="delimiter">[</span>OF le_PlusR Star_mono<span class="delimiter">[</span>OF le_PlusL<span class="delimiter">]</span><span class="delimiter">]</span> le_PlusR<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;&hellip; = Star (Plus r s)&quot;</span> <span class="command">by</span> simp
  <span class="command">finally</span> <span class="command">show</span> <span class="string">&quot;Times (Star (Plus r s)) (Times s (Star r)) &le; Star (Plus r s)&quot;</span> <span class="command">.</span>
<span class="command">qed</span>

<span class="command">text</span> <span class="verbatim">{*
It is useful to lift binary operators @{term Plus} and @{term Times}
to $n$-ary operators (that take a list as input).
*}</span>

<span class="command">definition</span> PLUS <span class="delimiter">::</span> <span class="string">&quot;&#39;a language list =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;PLUS xs &equiv; foldr Plus xs Zero&quot;</span>

<span class="command">lemma</span> \&lt;oo&gt;_foldr_Plus<span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; (foldr Plus xs s) = (&exist;x&isin;set (s # xs). \&lt;oo&gt; x)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct xs arbitrary<span class="delimiter">:</span> s<span class="delimiter">)</span> auto

<span class="command">lemma</span> \&lt;dd&gt;_foldr_Plus<span class="delimiter">:</span> <span class="string">&quot;\&lt;dd&gt; (foldr Plus xs s) a = foldr Plus (map (&lambda;r. \&lt;dd&gt; r a) xs) (\&lt;dd&gt; s a)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct xs arbitrary<span class="delimiter">:</span> s<span class="delimiter">)</span> simp_all

<span class="command">lemma</span> \&lt;oo&gt;_PLUS<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; (PLUS xs) = (&exist;x&isin;set xs. \&lt;oo&gt; x)&quot;</span>
  <span class="command">unfolding</span> PLUS_def \&lt;oo&gt;_foldr_Plus <span class="command">by</span> simp

<span class="command">lemma</span> \&lt;dd&gt;_PLUS<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;\&lt;dd&gt; (PLUS xs) a = PLUS (map (&lambda;r. \&lt;dd&gt; r a) xs)&quot;</span>
  <span class="command">unfolding</span> PLUS_def \&lt;dd&gt;_foldr_Plus <span class="command">by</span> simp

<span class="command">definition</span> TIMES <span class="delimiter">::</span> <span class="string">&quot;&#39;a language list =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;TIMES xs &equiv; foldr Times xs One&quot;</span>

<span class="command">lemma</span> \&lt;oo&gt;_foldr_Times<span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; (foldr Times xs s) = (&forall;x&isin;set (s # xs). \&lt;oo&gt; x)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct xs<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> PLUS_def<span class="delimiter">)</span>

<span class="command">primrec</span> tails <span class="keyword2">where</span>
  <span class="string">&quot;tails [] = [[]]&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;tails (x # xs) = (x # xs) # tails xs&quot;</span>

<span class="command">lemma</span> tails_snoc<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;tails (xs @ [x]) = map (&lambda;ys. ys @ [x]) (tails xs) @ [[]]&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct xs<span class="delimiter">)</span> auto

<span class="command">lemma</span> length_tails<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;length (tails xs) = Suc (length xs)&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct xs<span class="delimiter">)</span> auto

<span class="command">lemma</span> \&lt;dd&gt;_foldr_Times<span class="delimiter">:</span> <span class="string">&quot;\&lt;dd&gt; (foldr Times xs s) a =
  (let n = length (takeWhile \&lt;oo&gt; xs)
  in PLUS (map (&lambda;zs. TIMES (\&lt;dd&gt; (hd zs) a # tl zs)) (take (Suc n) (tails (xs @ [s])))))&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct xs<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> TIMES_def PLUS_def Let_def foldr_map o_def<span class="delimiter">)</span>

<span class="command">lemma</span> \&lt;oo&gt;_TIMES<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;\&lt;oo&gt; (TIMES xs) = (&forall;x&isin;set xs. \&lt;oo&gt; x)&quot;</span>
  <span class="command">unfolding</span> TIMES_def \&lt;oo&gt;_foldr_Times <span class="command">by</span> simp

<span class="command">lemma</span> TIMES_snoc_One<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;TIMES (xs @ [One]) = TIMES xs&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>induct xs<span class="delimiter">)</span> <span class="delimiter">(</span>auto simp<span class="delimiter">:</span> TIMES_def<span class="delimiter">)</span>

<span class="command">lemma</span> \&lt;dd&gt;_TIMES<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;\&lt;dd&gt; (TIMES xs) a = (let n = length (takeWhile \&lt;oo&gt; xs)
  in PLUS (map (&lambda;zs. TIMES (\&lt;dd&gt; (hd zs) a # tl zs)) (take (Suc n) (tails (xs @ [One])))))&quot;</span>
  <span class="command">unfolding</span> TIMES_def \&lt;dd&gt;_foldr_Times <span class="command">by</span> simp

<span class="command">section</span> <span class="verbatim">{* Context Free Languages *}</span>

<span class="command">context</span>
<span class="keyword2">fixes</span> init <span class="delimiter">::</span> <span class="string">&quot;&#39;n::enum&quot;</span>
<span class="keyword2">and</span>   prod <span class="delimiter">::</span> <span class="string">&quot;&#39;n =&gt; (&#39;t + &#39;n) language&quot;</span>
<span class="keyword2">begin</span>

<span class="command">primcorec</span> deep_subst <span class="delimiter">::</span> <span class="string">&quot;(&#39;t + &#39;n) language =&gt; &#39;t language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;deep_subst r =
     (let shallow_subst = PLUS (r # map (&lambda;N. Times (prod N) (\&lt;dd&gt; r (Inr N))) Enum.enum)
     in Lang (\&lt;oo&gt; shallow_subst) (&lambda;a. deep_subst (\&lt;dd&gt; shallow_subst (Inl a))))&quot;</span>

<span class="command">definition</span> subst <span class="keyword2">where</span>
  <span class="string">&quot;subst = deep_subst (prod init)&quot;</span>

<span class="command">end</span>

<span class="command">text</span> <span class="verbatim">{*
A context-free grammar consists of a list of productions for every nonterminal
and an initial nonterminal. The productions are required to be in weak Greibach
normal form, i.e. each right hand side of a production must either be empty or
start with a terminal.
*}</span>

<span class="command">locale</span> cfg <span class="delimiter">=</span>
<span class="keyword2">fixes</span> init <span class="delimiter">::</span> <span class="string">&quot;&#39;n::enum&quot;</span>
<span class="keyword2">and</span>   prod <span class="delimiter">::</span> <span class="string">&quot;&#39;n =&gt; (&#39;t + &#39;n) list list&quot;</span>
<span class="keyword2">assumes</span> weakGreibach<span class="delimiter">:</span> <span class="string">&quot;&forall;N. &forall;rhs &isin; set (prod N). case rhs of (Inr N # _) =&gt; False | _ =&gt; True&quot;</span>
<span class="keyword2">begin</span>

<span class="command">abbreviation</span> lang <span class="delimiter">::</span> <span class="string">&quot;&#39;t language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;lang &equiv; subst init (&lambda;N. PLUS (map (TIMES o map Atom) (prod N)))&quot;</span>

<span class="command">end</span>

<span class="command">section</span> <span class="verbatim">{* Word-theoretic Semantics of Languages *}</span>

<span class="command">text</span> <span class="verbatim">{*
We show our @{type language} codatatype being isomorphic to the standard
language representation as a set of lists.
*}</span>

<span class="command">primrec</span> in_language <span class="delimiter">::</span> <span class="string">&quot;&#39;a language =&gt; &#39;a list =&gt; bool&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;in_language L [] = \&lt;oo&gt; L&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;in_language L (x # xs) = in_language (\&lt;dd&gt; L x) xs&quot;</span>

<span class="command">primcorec</span> to_language <span class="delimiter">::</span> <span class="string">&quot;&#39;a list set =&gt; &#39;a language&quot;</span> <span class="keyword2">where</span>
  <span class="string">&quot;\&lt;oo&gt; (to_language L) = ([] &isin; L)&quot;</span>
<span class="delimiter">|</span> <span class="string">&quot;\&lt;dd&gt; (to_language L) = (&lambda;a. to_language {w. a # w &isin; L})&quot;</span>

<span class="command">lemma</span> in_language_to_language<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;Collect (in_language (to_language L)) = L&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>rule set_eqI<span class="delimiter">,</span> unfold mem_Collect_eq<span class="delimiter">)</span>
  <span class="command">fix</span> w <span class="command">show</span> <span class="string">&quot;in_language (to_language L) w = (w &isin; L)&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>induct w arbitrary<span class="delimiter">:</span> L<span class="delimiter">)</span> auto
<span class="command">qed</span>

<span class="command">lemma</span> to_language_in_language<span class="delimiter">[</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;to_language (Collect (in_language L)) = L&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> L<span class="delimiter">)</span> auto

<span class="command">lemma</span> in_language_bij<span class="delimiter">:</span> <span class="string">&quot;bij (Collect o in_language)&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>rule bijI&#39;<span class="delimiter">,</span> unfold o_apply<span class="delimiter">,</span> safe<span class="delimiter">)</span>
  <span class="command">fix</span> L R <span class="delimiter">::</span> <span class="string">&quot;&#39;a language&quot;</span> <span class="command">assume</span> <span class="string">&quot;Collect (in_language L) = Collect (in_language R)&quot;</span>
  <span class="command">then</span> <span class="command">show</span> <span class="string">&quot;L = R&quot;</span> <span class="command">unfolding</span> set_eq_iff mem_Collect_eq
    <span class="command">by</span> <span class="delimiter">(</span>coinduction arbitrary<span class="delimiter">:</span> L R<span class="delimiter">)</span> <span class="delimiter">(</span>metis in_language.simps<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> L <span class="delimiter">::</span> <span class="string">&quot;&#39;a list set&quot;</span>
  <span class="command">have</span> <span class="string">&quot;L = Collect (in_language (to_language L))&quot;</span> <span class="command">by</span> simp
  <span class="command">then</span> <span class="command">show</span> <span class="string">&quot;&exist;K. L = Collect (in_language K)&quot;</span> <span class="command">by</span> blast
<span class="command">qed</span>

<span class="command">lemma</span> to_language_bij<span class="delimiter">:</span> <span class="string">&quot;bij to_language&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>rule o_bij<span class="delimiter">[</span>of <span class="string">&quot;Collect o in_language&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">(</span>simp_all add<span class="delimiter">:</span> fun_eq_iff<span class="delimiter">)</span>

<span class="comment">(*&lt;*)</span>
<span class="command">hide_const</span> <span class="delimiter">(</span><span class="keyword2">open</span><span class="delimiter">)</span> TimesLR Times_Plus StarLR deep_subst subst

<span class="command">end</span>
<span class="comment">(*&gt;*)</span>
</pre>

</div>
</body>
</html>
